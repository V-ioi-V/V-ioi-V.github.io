---
title: 水壶问题（贝祖定理）
tags: leetcode
category: 算法
date: 2020/03/21 11:10
---

# 题目描述

有两个容量分别为 *x*升 和 *y*升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 *z*升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的 *z升* 水。

你允许：

- 装满任意一个水壶
- 清空任意一个水壶
- 从一个水壶向另外一个水壶倒水，直到装满或者倒空

**示例 1:** 

```
输入: x = 3, y = 5, z = 4
输出: True
```

**示例 2:**

```
输入: x = 2, y = 6, z = 5
输出: False
```

## 待补坑

- 一开始想着暴力递归，奈何空间复杂度过高而且不会优化，以后有机会补坑

错误代码如下

```c++
class Solution {
public:
    map<pair<int,int>,bool> mp;
    bool flag = 0;
public:
    void dfs(int x, int y, int z, int a, int b) {
        if (mp[make_pair(a,b)])return;
        mp[make_pair(a,b)] = 1;
        if (a == z || b == z||a+b==z) {
            flag = 1;
            return;
        }
        if (a) {
            int cnt = y - b;
            if (a <= cnt)b += a,a = 0;
            else b = y, a -= cnt;
            dfs(x, y, z, a, b);
        }
        if (b) {
            int cnt = x - a;
            if (b <= cnt)a += b,b = 0;
            else a = x, b -= cnt;
            dfs(x, y, z, a, b);
        }
        dfs(x,y,z,a,0);
        dfs(x,y,z,0,b);
        dfs(x, y, z, x, b);
        dfs(x, y, z, a, y);
    }

public:
    bool canMeasureWater(int x, int y, int z) {
        dfs(x, y, z, 0, 0);
        return flag;
    }
};
```

## 思路

**思路及算法**

预备知识：[贝祖定理](https://baike.baidu.com/item/裴蜀定理/5186593?fromtitle=贝祖定理&fromid=5185441)

我们认为，每次操作只会让桶里的水总量增加 `x`，增加 `y`，减少 `x`，或者减少 `y`。

你可能认为这有问题：如果往一个不满的桶里放水，或者把它排空呢？那变化量不就不是 `x` 或者 `y` 了吗？接下来我们来解释这一点：

- 首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。因为观察所有题目中的操作，操作的结果都至少有一个桶是空的或者满的；
- 其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；
- 再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。

因此，我们可以认为每次操作只会给水的总量带来 `x` 或者 `y` 的变化量。因此我们的目标可以改写成：找到一对整数 a, b，使得

​                                                                             **ax+by=z**

而只要满足 z<=x+y，且这样的 a, b存在，那么我们的目标就是可以达成的。这是因为：

- 若 a ≥0,*b*≥0，那么显然可以达成目标。

- 若 a<0，那么可以进行以下操作：

  1. 往 `y` 壶倒水；
  2. 把 `y` 壶的水倒入 `x` 壶；
  3. 如果 `y` 壶不为空，那么 `x` 壶肯定是满的，把 `x` 壶倒空，然后再把 `y` 壶的水倒入 `x` 壶。

  重复以上操作直至某一步时 `x` 壶进行了 a 次倒空操作，`y` 壶进行了 b次倒水操作。

- 若 b<0，方法同上，`x` 与 `y` 互换。

而贝祖定理告诉我们，ax+by=z 有解当且仅当 z 是 x, y 的最大公约数的倍数。因此我们只需要找到 x, y 的最大公约数并判断 z是否是它的倍数即可。

```c++
class Solution {
public:
    bool canMeasureWater(int x, int y, int z) {
        if(x+y<z)return 0;
        if(x==0||y==0)return z==0||(x+y)==z;
        return z%__gcd(x,y)==0;
    }
};
```

