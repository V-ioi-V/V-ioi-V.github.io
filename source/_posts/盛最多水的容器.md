---
title: 盛最多水的容器
tags: 瞎搞
category: 算法
date: 2020/03/18
---

# 题目描述

给你 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器，且 *n* 的值至少为 2。

 

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

 

**示例：**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49
```

## 思路

双指针法，从两边遍历，由于每条线的距离都是1，所以移动短的那根一定会移动到最大距离。

简单反证法证明：通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。

```txt
           |
           |                           
           |      |                     
           |      |                     
     ......|......|......               
——————————————————————————————————————— 
           m      n
```

如图，若m,n之间的面积为最大面积。

双指针方法的规律是：每次都会向内移动偏矮的指针（可观察案例）。要证明两个指针一定会移动到m和n位置，只需证明：

m左侧的指针点等于或矮于n，n右侧指针等于或矮于m。

假设m左侧有一个点p，高度高于n.

```txt
            |                            
        |   |                           
        |   |      |                     
        |   |      |                     
     ...|...|......|......               
——————————————————————————————————————— 
        p   m      n
```

因为:

```lisp
    AreaMN = ( n - m ) * min( arr[ m ], arr[ n ] )
    AreaPN = ( n - p ) * min( arr[ p ], arr[ n ] )
```

又：

```lisp
    (  n - m ) < ( n - p )
    min( arr[ m ], arr[ n ] ) = min( arr[ p ], arr[ n ] )
```

所以： `AreaMN < AreaPN`, 与m和n构成最大面积相矛盾，所以假设不成立，即m左侧的点都不高于n，即等于或矮于n。同理可证，n右侧指针等于或矮于m。所以通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。

## 代码

```c++
class Solution {
public:
    int maxArea(vector<int> &height) {
        int ans = 0;
        int i = 0, j = height.size()-1;
        while (i < j) {
            ans = max(ans, min(height[i], height[j]) * (j - i));
            if (height[i] < height[j])
                i++;
            else
                j--;
        }
        return ans;
    }
};
```

