---
title: 随机算法
tags: [思维,leetcode]
category: 算法
date: 2020/04/10 22:02
---

<font size=4>

# 蓄水池算法

## 问题描述

**给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。**

这个场景强调了3件事：

- 数据流长度N很大且不可知，所以不能一次性存入内存。

- 时间复杂度为O(N)。

- 随机选取m个数，每个数被选中的概率为m/N。

## 核心代码及原理

转自：https://www.jianshu.com/p/7a9ea6ece2af

```c++
int a[100010];
vector<int> reservoir(m);//reservoir为蓄水池

// init
for (int i = 0; i < reservoir.size(); i++) {
    reservoir[i] = dataStream[i];//数据流
}

for (int i = m; i < dataStream.size(); i++) {
    // 随机获得一个[0, i]内的随机整数
    int d = rand(i + 1);
    // 如果随机整数落在[0, m-1]范围内，则替换蓄水池中的元素
    if (d < m) {
      reservoir[d] = dataStream[i];
    }
}
```

**注：**这里使用已知长度的数组dataStream来表示未知长度的数据流，并假设数据流长度大于蓄水池容量m。

算法思路大致如下：

1. 如果接收的数据量小于m，则依次放入蓄水池。
2. 当接收到第i个数据时，i >= m，在[0, i]范围内取以随机数d，若d的落在[0, m-1]范围内，则用接收到的第i个数据替换蓄水池中的第d个数据。
3. 重复步骤2。

算法的精妙之处在于：**当处理完所有的数据时，蓄水池中的每个数据都是以m/N的概率获得的。**

下面用白话文推导验证该算法。假设数据开始编号为1.

**第i个接收到的数据最后能够留在蓄水池中的概率=第i个数据进入过蓄水池的概率*****之后第i个数据不被替换的概率**（第i+1到第N次处理数据都不会被替换）。

1. 当i<=m时，数据直接放进蓄水池，所以**第i个数据进入过蓄水池的概率=1**。
2. 当i>m时，在[1,i]内选取随机数d，如果d<=m，则使用第i个数据替换蓄水池中第d个数据，因此**第i个数据进入过蓄水池的概率=m/i**。
3. 当i<=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))*(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)...第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后**第i个数据不被替换的概率=m/(m+1)\*(m+1)/(m+2)\*...\*(N-1)/N=m/N**。
4. 当i>m时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，**之后第i个数据不被替换的概率=i/N**。
5. 结合第1点和第3点可知，当i<=m时，第i个接收到的数据最后留在蓄水池中的概率=1\*m/N=m/N。结合第2点和第4点可知，当i>m时，第i个接收到的数据留在蓄水池中的概率=m/i*i/N=m/N。综上可知，**每个数据最后被选中留在蓄水池中的概率为m/N**。

这个算法建立在统计学基础上，很巧妙地获得了“m/N”这个概率。

# 洗牌算法

头条一面遇到一个算法题：差不多是 在n个不同的数中随机取出不重复的m个数。洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，刚好可以解决该问题。

洗牌算法
    由抽牌、换牌和插牌衍生出三种洗牌算法，其中抽牌和换牌分别对应Fisher-Yates Shuffle和Knuth-Durstenfeld Shhuffle算法。

## Fisher-Yates Shuffle算法                                                      

最早提出这个洗牌方法的是 Ronald A. Fisher 和 Frank Yates，即 Fisher–Yates Shuffle，其基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，具体如下：

 1. 初始化原始数组和新数组，原始数组长度为n(已知)；

 2. 从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）；

 3. 从剩下的k个数中把第p个数取出；

 4. 重复步骤2和3直到数字全部取完；

 5. 从步骤3取出的数字序列便是一个打乱了的数列。

 下面证明其随机性，即每个元素被放置在新数组中的第i个位置是1/n（假设数组大小是n）。

 证明：一个元素m被放入第i个位置的概率P = 前i-1个位置选择元素时没有选中m的概率 * 第i个位置选中m的概率，即

![1.jpg](https://i.loli.net/2020/05/05/4lm9jGYnPtJZsX7.gif)

```c++
#define N 10
#define M 5

void Fisher_Yates_Shuffle(vector<int> &arr, vector<int> &res) {
    srand((unsigned) time(NULL));
    int k;
    for (int i = 0; i < M; ++i) {
        k = rand() % arr.size();
        res.push_back(arr[k]);
        arr.erase(arr.begin() + k);
    }
}
```

 时间复杂度为O(n*n),空间复杂度为O(n).
## Knuth-Durstenfeld Shuffle  
​        Knuth 和 Durstenfeld  在Fisher 等人的基础上对算法进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。
算法步骤为：

1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；
2. 生成一个从 0 到 n - 1 的随机数 x；
3. 输出 arr 下标为 x 的数值，即为第一个随机数；
4. 将 arr 的尾元素和下标为 x 的元素互换；
5. 同2，生成一个从 0 到 n - 2 的随机数 x；
6. 输出 arr 下标为 x 的数值，为第二个随机数；
7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；
   ……

如上，直到输出 m 个数为止

该算法是经典洗牌算法。它的proof如下：
对于arr[i],洗牌后在第n-1个位置的概率是1/n（第一次交换的随机数为i）
在n-2个位置概率是[(n-1)/n] * [1/(n-1)] = 1/n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i=n-1，第一交换arr[n-1]会被换到一个随机的位置））
在第n-k个位置的概率是[(n-1)/n] * [(n-2)/(n-1)] *...* [(n-k+1)/(n-k+2)] *[1/(n-k+1)] = 1/n
（第一个随机数不要为i，第二次不为arr[i]所在的位置(随着交换有可能会变)……第n-k次为arr[i]所在的位置）.

```c++
void Knuth_Durstenfeld_Shuffle(vector<int> &arr) {
    for (int i = arr.size() - 1; i >= 0; --i) {
        srand((unsigned) time(NULL));
        swap(arr[rand() % (i + 1)], arr[i]);
    }
}
```

时间复杂度为O(n),空间复杂度为O(1),缺点必须知道数组长度n.

原始数组被修改了，这是一个原地打乱顺序的算法，算法时间复杂度也从Fisher算法的 O(n^2)提升到了O(n)。由于是从后往前扫描，无法处理不知道长度或动态增长的数组。

## Inside-Out Algorithm
   Knuth-Durstenfeld Shuffle 是一个内部打乱的算法，算法完成后原始数据被直接打乱，尽管这个方法可以节省空间，但在有些应用中可能需要保留原始数据，所以需要另外开辟一个数组来存储生成的新序列。
    Inside-Out Algorithm 算法的基本思思是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k），这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。

   如果知道arr的lengh的话，可以改为for循环，由于是从前往后遍历，所以可以应对arr[]数目未知的情况，或者arr[]是一个动态增加的情况。

证明如下：
原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1/i) * [i/(i+1)] * [(i+1)/(i+2)] *...* [(n-1)/n] = 1/n，（即第i次刚好随机放到了该位置，在后面的n-i 次选择中该数字不被选中）。
原数组的第 i 个元素（随机到的数）在新数组的 i+1 （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1/k) * [k/(k+1)] * [(k+1)/(k+2)] *...* [(n-1)/n] = 1/n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。         

```c++
void Inside_Out_Shuffle(const vector<int> &arr, vector<int> &res) {
    res.assign(arr.size(), 0);
    copy(arr.begin(), arr.end(), res.begin());
    int k;
    for (int i = 0; i < arr.size(); ++i) {
        srand((unsigned) time(NULL));
        k = rand() % (i + 1);
        res[i] = res[k];
        res[k] = arr[i];
    }
}
```

 时间复杂度为O(n),空间复杂度为O(n). 