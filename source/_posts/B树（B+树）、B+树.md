---
title: B树（B-树）、B+树
tags: 数据结构
category: 算法短板
---



# B-树

## 定义

B树（B-树），是一种多路搜索树（并非二叉的）：

- 定义任意非叶子节点最多可以有M个儿子节点；且M>2；
- 则根节点（非叶子节点前提下）的儿子数为：[2，M]；
- 除根节点外的非叶子节点的儿子数为[M/2，M]；
- 每个结点存放至少M/2 - 1 （向上取整）且至多M -1 个关键字（至少为2）；
- 非叶子结点的关键字个数 = 指向子节点的指针数-1；
- 非叶子节点的关键字：K[1],K[2],K[3],…,K[M-1;且K[i] < K[i +1];
- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
- 所有叶子结点位于同一层；

如(M = 3)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190815211241789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70)

​          B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点（每两个关键字之间会对应一个指向子节点的指针）；重复，直到所对应的儿子指针为空，或已经是叶子结点；

## 特性

- 关键字集合分布在整颗树中；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束；
- 其搜索性能等价于在关键字全集内做一次二分查找；
- 自动层次控制；

# B+树

## 定义

B+树是B-树的变体，也是一种多路搜索树，主要为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，其定义基本与B-树同，除了：

- 非叶子结点的子树指针与关键字个数相同；

- **非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；**

- 为所有叶子结点增加一个链指针；

- 所有关键字都在叶子结点出现；

如：（M=3）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817142029576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70)

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在

非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

## 特性

- 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；

- 不可能在非叶子结点命中；

- 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；

### B+树的插入操作

B+树的插入必须保证插入后叶节点中的记录依然排序，同时需要考虑插入B+树的三种情况，每种情况都可能会导致不同的插入算法，如表5-1所示。 

![1.png](https://i.loli.net/2020/03/10/T4rz2o7Qgu5aVNk.png)

我们用实例来分析B+树的插入，我们插入28这个键值，发现当前Leaf Page和Index Page都没有满，我们直接插入就可以了。

![2.png](https://i.loli.net/2020/03/10/1l76vxQewYhSPg2.png)

这次我们再插入一条70这个键值，这时原先的Leaf Page已经满了，但是Index Page还没有满，符合表5-1的第二种情况，这时插入Leaf Page后的情况为50、55、60、65、70。我们根据中间的值60拆分叶节点。

![4.png](https://i.loli.net/2020/03/10/itmFSBUC7ATjJxz.png)



因为图片显示的关系，这次我没有能在各叶节点加上双向链表指针。最后我们来插入记录95，这时符合表5-1讨论的第三种情况，即Leaf Page和Index Page都满了，这时需要做两次拆分。

![5.png](https://i.loli.net/2020/03/10/aCx1kRVJYDZsIrz.png)

可以看到，不管怎么变化，B+树总是会保持平衡。但是为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘的操作，应该在可能的情况下尽量减少页的拆分。因此，B+树提供了旋转（rotation）的功能。

*旋转发生在Leaf Page已经满了、但是其左右兄弟节点没有满的情况下。*这时B+树并不会急于去做拆分页的操作，而是将记录移到所在页的兄弟节点上。通常情况下，左兄弟被首先检查用来做旋转操作，这时我们插入键值70，其实B+树并不会急于去拆分叶节点，而是做旋转50，55旋转。

![6.png](https://i.loli.net/2020/03/10/7ZxohQlCzUVacHr.png)

可以看到，采用旋转操作使B+树减少了一次页的拆分操作，而这时B+树的高度依然还是2。



### B+树的删除操作

B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。B+树的删除操作同样必须保证删除后叶节点中的记录依然排序，同插入一样，B+树的删除操作同样需要考虑如表5-2所示的三种情况，与插入不同的是，删除根据填充因子的变化来衡量。 

![7.png](https://i.loli.net/2020/03/10/R3YilsqErS1aMnK.png)

首先，删除键值为70的这条记录，该记录符合表5-2讨论的第一种情况，删除后。

![8.png](https://i.loli.net/2020/03/10/MNG54mWaf3gQu7C.png)

接着我们删除键值为25的记录，这也是表5-2讨论的第一种情况，但是该值还是Index Page中的值，因此在删除Leaf Page中25的值后，还应将25的右兄弟节点的28更新到Page Index中，最后可得到图。

![9.png](https://i.loli.net/2020/03/10/OI67SZvkEYFz9J1.png)

<font color="red">图片错误，应该为28</font>

最后我们来看删除键值为60的情况，删除Leaf Page中键值为60的记录后，填充因子小于50%，这时需要做合并操作，同样，在删除Index Page中相关记录后需要做Index Page的合并操作，最后得到图。

![10.png](https://i.loli.net/2020/03/10/zKJRir7qfNPOvGL.png)

本文转自《MySQL 技术内幕  InnoDB存储引擎》



# B+树比B树的优势

|          | B树                              | B+树                                                         |
| -------- | -------------------------------- | ------------------------------------------------------------ |
| 关键字   | 关键字分布在整棵树中，只出现一次 | 所有关键字都出现在叶节点的链表中，且有序                     |
| 搜索命中 | 可能在树中任意节点命中，搜索结束 | 只可能在叶节点中命中，查询路径稳定                           |
| 非叶节点 | 非叶节点包含关键字，也包含数据   | 非叶节点相当于索引帮助搜索到叶节点，叶节点相当于存储关键字数据的数据层 |
| 叶节点   |                                  | 增加了链表指针，相当于存储关键字数据的数据层                 |





**为什么说B+tree比B-树更适合实际应用中操作系统的文件索引和数据库索引？**

- **B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，IO次数更少**

  B+tree的内部结点并没有指向关键字具体信息的指针。因此**其内部结点相对B树更小**。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree ( 一个结点最多8个关键字) 的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

- **B+树的查询必须最终找到叶子节点，而B-树只需要找到匹配的元素即可。B+树性能稳定**

  由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

- **范围查询方便。B-树只能依靠繁琐的中序遍历，而B+树只需要在链表上遍历即可**



# B*树

## 定义

- B\*树是B+树一种变形，它是在B+树的基础上，将索引层以指针连接起来，使搜索取值更加快捷。

*如下图（M = 3）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817142644325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70)*

但是B树又在B+树的基础上产生了一系列的变化，如下：

- B\*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3代替B+树的1/2）；
- B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
- B\*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
  所以B\*树相对于B+树，空间利用率上有所提高，查询速率也有所提高。

## 总结

- 二叉搜索树：二叉树，每个结点只存储一个关键字且值大于左子树，小于右子树。

- B（B-）树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

- B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点
  中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

- B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率
  从1/2提高到2/3；

---



原文链接：https://blog.csdn.net/A_zhangq/article/details/99662693