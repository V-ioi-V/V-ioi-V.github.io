---
title: 用户态和内核态
tags: 操作系统
category: CS大学生必备
date: 2020/03/22 12:05
---

操作系统是用户与计算机硬件之间的接口

<!--more-->

<font size=4>

# 4GB虚拟内存

1.linux进程有4GB地址空间，如图所示：

![2.png](https://i.loli.net/2020/04/29/tFw3IL5HoNnOQMk.png)

3G-4G大部分是共享的，是内核态的地址空间。这里存放整个内核的代码和所有的内核模块以及内核所维护的数据。

### 内核空间

- 与进程有关的数据结构段

　　每个进程都自己独特的PCB和页表，映射到不同的物理内存。

- 内核代码段

　　所有进程的内核代码段都映射到同样的物理内存，并在内存中持续存在。

### 用户空间

- 正文段

　　存放代码和常量值（字面值常量）

- 未初始化数据段（BSS段）

　　存放未初始化的**全局变量**

- 初始化数据段

　　存放已经初始化的**全局变量**

- 堆

　　动态内存的分配

- 栈

　　存放**局部变量**

- 内存映射段

　　常被用来加载共享库。

**内存映射**

　　将虚拟内存空间与磁盘上的文件关联起来，来初始化这个虚拟内存空间的内容，这个过程叫内存映射。

**共享库**

1）几乎每个程序都会用到如printf之类的标准I/O函数，如果只使用静态库，这些函数的代码将会被复制到正文段中，对于一个运行上百个进程的系统来说，这是一种对内存的浪费，所以提出共享库

2）程序第一此执行时，用动态链接的方法将程序和共享库链接，减少了可执行文件的长度



2、特权级的概念：

对于任何操作系统来说，创建一个进程是核心功能。创建进程要做很多工作，会消耗很多物理资源。比如分配物理内存，父子进程拷贝信息，拷贝设置页目录页表等等，这些工作得由特定的进程去做，所以就有了特权级别的概念。最关键的工作必须交给特权级最高的进程去执行，这样可以做到集中管理，减少有限资源的访问和使用冲突。inter x86架构的cpu一共有四个级别，0-3级，0级特权级最高，3级特权级最低。

3、用户态和内核态的概念：

当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。

4、用户态和内核态的切换

当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。

用户态切换到内核态的3种方式

（1）系统调用

这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如fork（）就是执行了一个创建新进程的系统调用。系统调用的机制和新是使用了操作系统为用户特别开放的一个中断来实现，如Linux的int 80h中断。

（2）异常

当cpu在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。

（3）外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。

这三种方式是系统在运行时由用户态切换到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。从触发方式上看，切换方式都不一样，但从最终实际完成由用户态到内核态的切换操作来看，步骤有事一样的，都相当于执行了一个中断响应的过程。系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本一致。

5、用户态到内核态具体的切换步骤：

（1）从当前进程的描述符中提取其内核栈的ss0及esp0信息。

（2）使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。

（3）将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。

# 用户态和内核态

通过**系统调用**将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。

**用户态：**用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。**

**内核态：**其实从本质上说就是我们所说的内核，它是一种**特殊的软件程序**，特殊在哪儿呢？**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。

用户态是普通的函数调用，系统态是系统函数的调用。

普通的函数调用有jump到相应的函数，或者用inline直接替换掉该函数



## 系统调用

程序员可以使用操作系统内核中的功能。

**系统调用**是操作系统的最小功能单位。根据不同的应用场景，不同的Linux发行版本提供的系统调用数量也不尽相同，大致在240-350之间。这些系统调用组成了用户态跟内核态交互的基本接口，**例如：用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移，如果用户态多处申请20K动态内存，同时又释放呢？这个内存的管理就变得非常的复杂。**

**系统调用执行过程**

- 保存系统调用号
- 执行int 0x80(或对等功能)，陷入到内核态
- 保护现场
- 根据系统调用号，检索系统调用表，找到系统调用实现例程的人口地址
- 执行系统调用例程
- 返回用户态

**系统是如何通过系统调用号和系统调用表找到调用实现例程的起始地址的**

首地址+表长×调用号

**操作系统提供系统调用优点**

- 使编程更加容易，把用户从学习硬件设备的低级编程特性中释放出来
- 提高了系统的安全性

## 用户态到内核态怎样切换？

往往我们的系统的资源是固定的，例如内存2G，CPU固定，磁盘2TB，网络接口固定。所以就需要操作系统对资源进行有效的利用。假设某个应用程序过分的访问这些资源，就会导致整个系统的资源被占用，如果不对这种行为进行限制和区分，就会导致资源访问的冲突。所以，Linux的设计的初衷：**对不同的操作给与不同的“权限”**。Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态。

各位有没有发现，前面讲了这么多内核态和用户态什么不同，其实用一句话就能概括：**它们权限不同**。用户态的进程能够访问的资源受到了极大的控制，而运行在内核态的进程可以“**为所欲为**”。一个进程可以运行在用户态也可以运行在内核态，那它们之间肯定存在用户态和内核态切换的过程。打一个比方：**C库接口malloc申请动态内存，malloc的实现内部最终还是会调用brk（）或者mmap（）系统调用来分配内存。**

**那为问题又来了，从用户态到内核态到底怎么进入？只能通过系统调用吗？还有其他方式吗？**

从用户态到内核态切换可以通过三种方式：

**系统调用**

应用程序主动向操作系统发出的服务请求

**异常**

违法指令或者其他原因导致当前指令执行失败  (如：缺页异常)后的处理请求

**中断**

来自硬件设备的处理请求

![5.png](https://i.loli.net/2020/05/05/8NHpwDLOcTiB9ua.png)

## 为什么要划分用户态和系统态？

一个最主要原因是要把用户程序和系统程序区分开，以利于程序的共享和保护。显然，这也是以增加系统复杂度和系统开销为代价的。
