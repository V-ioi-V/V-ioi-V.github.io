---
title: 用户态和内核态
tags: 操作系统
category: CS大学生必备
date: 2020/03/22 12:05
---

# 用户态和内核态

通过**系统调用**将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。

**用户态：**用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。**

**内核态：**其实从本质上说就是我们所说的内核，它是一种**特殊的软件程序**，特殊在哪儿呢？**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。

用户态是普通的函数调用，系统态是系统函数的调用。

普通的函数调用有jump到相应的函数，或者用inline直接替换掉该函数

## 系统调用

**系统调用**是操作系统的最小功能单位。根据不同的应用场景，不同的Linux发行版本提供的系统调用数量也不尽相同，大致在240-350之间。这些系统调用组成了用户态跟内核态交互的基本接口，**例如：用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移，如果用户态多处申请20K动态内存，同时又释放呢？这个内存的管理就变得非常的复杂。**

**系统调用执行过程**

- 保存系统调用号
- 执行int 0x80(或对等功能)，陷入到内核态
- 保护现场
- 根据系统调用号，检索系统调用表，找到系统调用实现例程的人口地址
- 执行系统调用例程
- 返回用户态

**系统是如何通过系统调用号和系统调用表找到调用实现例程的起始地址的**

首地址+表长×调用号

**操作系统提供系统调用优点**

- 使编程更加容易，把用户从学习硬件设备的低级编程特性中释放出来
- 提高了系统的安全性

## 用户态到内核态怎样切换？

往往我们的系统的资源是固定的，例如内存2G，CPU固定，磁盘2TB，网络接口固定。所以就需要操作系统对资源进行有效的利用。假设某个应用程序过分的访问这些资源，就会导致整个系统的资源被占用，如果不对这种行为进行限制和区分，就会导致资源访问的冲突。所以，Linux的设计的初衷：**对不同的操作给与不同的“权限”**。Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态。

各位有没有发现，前面讲了这么多内核态和用户态什么不同，其实用一句话就能概括：**它们权限不同**。用户态的进程能够访问的资源受到了极大的控制，而运行在内核态的进程可以“**为所欲为**”。一个进程可以运行在用户态也可以运行在内核态，那它们之间肯定存在用户态和内核态切换的过程。打一个比方：**C库接口malloc申请动态内存，malloc的实现内部最终还是会调用brk（）或者mmap（）系统调用来分配内存。**

**那为问题又来了，从用户态到内核态到底怎么进入？只能通过系统调用吗？还有其他方式吗？**

从用户态到内核态切换可以通过三种方式：

1. 其实系统调用本身就是中断，但是软件中断，跟硬中断不同。
2. 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。
3. 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。

## 为什么要划分用户态和系统态？

一个最主要原因是要把用户程序和系统程序区分开，以利于程序的共享和保护。显然，这也是以增加系统复杂度和系统开销为代价的。
