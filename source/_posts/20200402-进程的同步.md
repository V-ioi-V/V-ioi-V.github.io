---
title: 进程的同步
tags: 操作系统
category: CS大学生必备
date: 2020/04/02 11:33
---



保证进程并发或者并行执行的时结果的正确性，采用同步机制对进程的执行进行控制

<!--more-->



# 临界资源:

以互斥方式访问的共享资源叫做临界资源

**临界资源：**以互斥方式访问的共享资源叫做临界资源。
**临界区：**每个进程中访问临界资源的那段代码称为
           临界区。
**进入区：**检查是否可以进入临界区并对临界区“加锁”
           的代码。
**退出区：**释放临界区访问权的代码。

# 进程同步的任务就是：

​    1、在资源共享的情况下：保证诸进程以互斥的方式访问临界资源—必须以互斥方式访问的共享资源；
​    2、在相互合作的关系中：进程同步的主要任务是保证相互合作的诸进程在执行次序上协调，相互合作的进程可能同时存在资源共享的关系。

# 同步机制应遵循的准则

- **空闲让进：**一个共享资源我不用了把它放到原来位置去,让别人去用
- **忙则等待：**临界资源正在被某个进程使用，其他进程想要使用临界资源就必须等待临界资源被释放，不同的同步机制实现方式不一样
- **有限等待：**对要求访问临界资源的进程，应保证有限时间内能进入自己的临界区，以免陷入饥饿状态，就是无限等待
- **让权等待：**当进程不能进入自己的临界区时，应立即释放处理机，让出cpu的使用权

# 同步实现的具体方式

## 信号量机制

用信号量的值表示共享资源的使用情况（包括临界资源）

### 整型信号量  

​      **定义：**整型信号量是表示共享资源状态且只能由特殊的原子操作改变的整型量。（其值好比信号灯的颜色）**不同的临界资源要有不同的整形信号量。**
​     **思路：**定义一个整型变量，用整型变量值来标记资源使用情况：<font color="red">如整型量>0,说明有可用资源；整型量≤0说明资源忙，进程必须等待。对于一次只允许一个进程访问的CS，可定义一个用于互斥的整型信号量，并被初始化为1。</font>

​     **两种操作：**wait 和 signal

```c++
var s:integer;    //s为整型信号量
wait(s){            //用于申请资源
        while s≤0 do no-op;//执行空操作来实现忙则等待
        s=s-1;
}
signal(s){          //用于释放资源
        s=s+1;
}
```

信号量具有临界资源的特点，但不是临界资源，是用来实现胡扯和协调的特殊临界资源。

​      **信号量不设置成原子操作的原因？**

设置成原子操作，会关掉wait和signal外面的中断，执行时间过长的话会导致长时间关掉中断，影响效率，系统会紊乱，计时也会出现问题。

#### 总结

- 整型信号量的值只能由wait和signal操作改变
- wait和signal 操作都是原子操作，既在这两个操作中对信号量的访问是不能被中断的。（为什么？）不 然可能会出现1+1！=2的情况出现
- 原子操作可以通过关中断来实现。（为什么对临界资源的访问不简单地通过关中断来实现？）
- 整型信号量机制的实例:Linux中的自旋锁SpinLock
- 不同的资源对应不同的信号量，并不是系统中所有的资源用同一个信号量表示.

### 记录性信号量

**记录型信号量的数据类型**

```c++
Type  semaphore=record
Value:integer        //可用资源数量
L:list of process    //阻塞队列,就是把进程控制块插入到L中
end.
```

**wait 操作**

```c++
procedure wait(s)
var s:semaphore
begin
     s.value=s.value-1;//申请资源
     if s.value<0 then//系统中已经没有可用资源
          block(s.L)  //阻塞到阻塞队列L中，把执行态变为阻塞态，把进程控制块插入L中
end.
```

block是自我阻塞，就是自己主动放弃了CPU，把使用权交给系统，系统再转去分配CPU

**signal操作**

```c++
procedure signal(s)
var s:semaphore
begin
    s.value=s.value+1; //释放资源
    if s.value<=0 then //说明还有申请不到资源的进程在s信号量的阻塞进程里
        wakeup(s.L)    //有可用资源，就把L中的一个进程唤醒
end.
```

wakeup：把阻塞态变为就绪态，从阻塞队列移到就绪队列里。

# 经典同步问题

## 生产者消费者问题

**问题描述：**    

  生产者进程生产消息，并将消息提供给消费者进程消费。为使生产者进程和消费者进程能并发执行，在它们之间设置了一个具有n个缓冲区的缓冲池，生产者进程可以将它所生产的消息放入一个缓冲区中，消费者进程可以从一个缓冲区中取得一个消息消费。**任意两个进程必须以互斥的方式访问公共缓冲池**。当缓冲池空时，消费者进程必须等待；当缓冲池装满消息时，生产者进程必须等待。

![Picture1.png](https://i.loli.net/2020/04/09/JnOMYVNCkhIE4Dl.png)

**需要解决的问题：**
①对缓冲池的互斥访问。

②对生产者进程、消费者进程的“协调”，即：有产品时才能消费，无产品时，必须先生产后消费；有空间时才能生产，空间满时，必须先消费再生产。

**信号量的设置：**
   ①一个互斥信号量，mutex用于实现对公共缓冲池的互斥访问，初值为1。
   ②两个同步信号量，分别表示可用资源数。
     empty：表示空缓冲区数,初值为n
     full： 表示装有产品的缓冲区数，初值为0，(一个缓冲区中放一个产品)。

**同步程序：**

```c++
 Producer://生产者                           
 begin                                  
   repeat                                 
   …                                     
   produce an item in nextp;                    
   wait(empty);                             
   wait(mutex);                              
   buffer(in):=nextp;                        
   in:=(in+1)mod n　//写入数据指针
   signal(mutex);                            
   signal(full)；
 until false;  
 end    
```

```c++
Consumer://消费者
  begin
     repeat
     …
     wait(full);
     wait(mutex);
     nextc:=buffer(out);
     out:=(out+1)mod n;　//取数据指针
     signal(mutex);
     signal(empty)；
     consume item in nextc;
     until false; 
     end

```

 **说明：**
①wait 和signal操作成对出现

②wait操作的顺序不能颠倒

③对具有相互合作关系的进程，提供解决问题的模型

##　读者-写者问题