---
title: 僵尸进程和孤儿进程
tags: 操作系统
category: CS大学生必备
date: 2020/03/23 17:36
---

# 僵尸进程

调用fork()函数以后，拷贝出一个子进程来。

僵尸进程即子进程先于父进程退出后，子进程的PCB（进程控制块）需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程，僵尸进程实际上是一个已经死掉的进程。我们用代码来看一下

```c++
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<assert.h>
#include<sys/types.h>

int main()
{
    pid_t pid=fork();

    if(pid==0)  //子进程
    {
        printf("child id is %d\n",getpid());//得到自身id
        printf("parent id is %d\n",getppid());//得到父进程id
    }
    else  //父进程不退出，使子进程成为僵尸进程
    {
        while(1){}
    }
    exit(0);//只有子进程执行到了这一步
}
```

我们将它挂在后台执行，可以看到结果，用ps可以看到子进程后有一个\<defunct> ,**defunct**是已死的，僵尸的意思,可以看出这时的子进程已经是一个僵尸进程了。因为子进程已经结束，而其父进程并未释放其PCB，所以产生了这个僵尸进程。

![Screenshot from 2020-03-23 16-56-08.png](https://i.loli.net/2020/03/23/lLwSmBU2HF6yqfT.png)

​         一个进程在调用exit(0)命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。

​        在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经**放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间**。这个僵尸进程需要它的父进程来为它收尸，如果他的父进程没有处理这个僵尸进程的措施，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。  

## 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

子进程死亡需要父进程来处理，那么意味着正常的进程应该是子进程先于父进程死亡。当父进程先于子进程死亡时，子进程死亡时没父进程处理，这个死亡的子进程就是孤儿进程。

但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，因为它终究是被系统回收了。不会像僵尸进程那样占用ID,损害运行系统。

```c++
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<assert.h>
#include<sys/types.h>

int main()
{
    pid_t pid=fork();

    if(pid==0)
    {
        printf("child ppid is %d\n",getppid());
        sleep(10);     //为了让父进程先结束
        printf("child ppid is %d\n",getppid());
    }
    else
    {
        printf("parent id is %d\n",getpid());
    }

    exit(0);
}
```

![Screenshot from 2020-03-23 17-18-56.png](https://i.loli.net/2020/03/23/XZ1eK5RrwhVQUE2.png)

从执行结果来看，此时由`pid == `父进程创建的子进程，其输出的父进程`pid == 1`，说明当其为孤儿进程时被init进程回收，最终并不会占用资源，这就是为什么要将孤儿进程分配给init进程。

### 僵尸进程与孤儿进程的危害

​     如果有大量的僵尸进程驻在系统之中，必然消耗大量的系统资源。但是系统资源是有限的，因此当僵尸进程达到一定数目时，系统因缺乏资源而导致奔溃。所以在实际编程中，避免和防范僵尸进程的产生显得尤为重要。

孤儿进程它会被init最终回收掉，所以危害相对来说要小很多，但是僵尸进程因为会占用大量的**进程号**和**系统资源**，如果父进程一直不结束，那么init进程也接管不了，这样就会一直消耗资源源，所以危害相对要高一些。