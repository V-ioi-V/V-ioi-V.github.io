---
title: 僵尸进程和孤儿进程
tags: 操作系统
category: CS大学生必备
date: 2020/03/23 17:36
---

僵尸进程和孤儿进程

<!--more-->

# 为什么要创建子进程

在程序设计时，某一个具体的功能模块可以通过函数或是线程等不同的形式来实现。对于同一进程而言，这些函数、线程都是存在于同一个地址空间下的，而且在执行时，大多只对与其相关的一些数据进行处理。如果算法存在某种错误，将有可能破坏与其同处一个地址空间的其他一些重要内容，这将造成比较严重的后果。为保护地址空间中的内容可以考虑将那些需要对地址空间中的数据进行访问的操作部分放到另外一个进程的地址空间中运行，并且只允许其访问原进程地址空间中的相关数据。具体的，可在进程中通过CreateProcess（）函数去创建一个子进程，子进程在全部处理过程中只对父进程地址空间中的相关数据进行访问，**从而可以保护父进程地址空间中与当前子进程执行任务无关的全部数据**。对于这种情况，子进程所体现出来的作用同函数和线程比较相似，可以看成是父进程在运行期间的一个过程为此，需要由父进程来掌握子进程的启动、执行和退出。创建子进程才能多道程序并发执行，linux初始化的时候会创建swap进程、然后是init进程和一个init进程的兄弟进程，所有的进程（运行的程序）都是从父进程演化出去的。

# 父子进程的关系

关于资源：子进程得到的是除了代码段是与父进程共享的意外，其他所有的都是得到父进程的一个副本度，子进程的所有资源都继承父进程，得到父进程资源的副本，既然为副本，也就是说，二者并不共享地址空间。，两个是单独的进程，继承了以后二者就没有什么关联了，子进程单独运行。（采用问写时复制技术）
关于文件描述符：继承父进程的文件描述符时，相当于调用了dup函数，父子进程共享文件表项，即共同操作同一个文件，一个进程修改了文件，另一个进程也知道此文件被修改了。

# 僵尸进程

调用fork()函数以后，拷贝出一个子进程来。

僵尸进程即子进程先于父进程退出后，子进程的PCB（进程控制块）需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程，僵尸进程实际上是一个已经死掉的进程。我们用代码来看一下

```c++
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<assert.h>
#include<sys/types.h>

int main()
{
    pid_t pid=fork();

    if(pid==0)  //子进程
    {
        printf("child id is %d\n",getpid());//得到自身id
        printf("parent id is %d\n",getppid());//得到父进程id
    }
    else  //父进程不退出，使子进程成为僵尸进程
    {
        while(1){}
    }
    exit(0);//只有子进程执行到了这一步
}
```

我们将它挂在后台执行，可以看到结果，用ps可以看到子进程后有一个\<defunct> ,**defunct**是已死的，僵尸的意思,可以看出这时的子进程已经是一个僵尸进程了。因为子进程已经结束，而其父进程并未释放其PCB，所以产生了这个僵尸进程。

![Screenshot from 2020-03-23 16-56-08.png](https://i.loli.net/2020/03/23/lLwSmBU2HF6yqfT.png)

​         一个进程在调用exit(0)命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。

​        在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经**放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间**。这个僵尸进程需要它的父进程来为它收尸，如果他的父进程没有处理这个僵尸进程的措施，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。  

# 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

子进程死亡需要父进程来处理，那么意味着正常的进程应该是子进程先于父进程死亡。当父进程先于子进程死亡时，子进程死亡时没父进程处理，这个死亡的子进程就是孤儿进程。

但孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，因为它终究是被系统回收了。不会像僵尸进程那样占用ID,损害运行系统。

```c++
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<assert.h>
#include<sys/types.h>

int main()
{
    pid_t pid=fork();

    if(pid==0)
    {
        printf("child ppid is %d\n",getppid());
        sleep(10);     //为了让父进程先结束
        printf("child ppid is %d\n",getppid());
    }
    else
    {
        printf("parent id is %d\n",getpid());
    }

    exit(0);
}
```

![Screenshot from 2020-03-23 17-18-56.png](https://i.loli.net/2020/03/23/XZ1eK5RrwhVQUE2.png)

从执行结果来看，此时由`pid == `父进程创建的子进程，其输出的父进程`pid == 1`，说明当其为孤儿进程时被init进程回收，最终并不会占用资源，这就是为什么要将孤儿进程分配给init进程。

# 僵尸进程与孤儿进程的危害

​     如果有大量的僵尸进程驻在系统之中，必然消耗大量的系统资源。但是系统资源是有限的，因此当僵尸进程达到一定数目时，系统因缺乏资源而导致奔溃。所以在实际编程中，避免和防范僵尸进程的产生显得尤为重要。

孤儿进程它会被init最终回收掉，所以危害相对来说要小很多，但是僵尸进程因为会占用大量的**进程号**和**系统资源**，如果父进程一直不结束，那么init进程也接管不了，这样就会一直消耗资源源，所以危害相对要高一些。