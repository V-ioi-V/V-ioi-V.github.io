---
title: C++内存对齐
tags: C++
category: CS大学生必备
date: 2020/05/10 10:27
---

<font size=4>

简单地说就是每次在内存中存放的偏移地址都必须是变量大小的倍数，不是倍数就在前面补充字节让偏移量成为倍数，作用是方便存取。

<!--more-->

# 引言

- int 4个字节 ，char 1个字节， double 8个字节，*（指针） 4个字节

在面试中被面试官问问到过这样的问题。

`struct A{int a;char b;double c;};`

这个结构体在内存中占多少字节，当时以为是13个，但是好像不是

# 介绍
## 什么是字节对齐
　　现代计算机中内存空间都是按照字节划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是字节对齐。

## 字节对齐的原因和作用
　　各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。

# 举例

```c++
struct MyStruct 
{ 
double a; 
char b; 
int c 
}; 
```

​       对结构MyStruct采用sizeof会出现什么结果呢？sizeof(MyStruct)为多少呢？也许你会这样求： 
　　sizeof(MyStruct)=sizeof(double)+sizeof(char)+sizeof(int)=13 
​       但是当在IDE中测试上面结构的大小时，发现sizeof(MyStruct)为16。
这是GCC对变量存储的一个特殊处理。为了提高CPU的存储速度，GCC对一些变量的起始地址做了“对齐”处理。在默认情况下，GCC规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。

```c++
struct A
{
    char a;
    //偏移量为0，满足对齐方式，a占用1个字节；
    double b;
    //下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，b存放在偏移量为8的地址上，它占用8个字节。
    int c;
    //下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，c存放在偏移量为16的地址上，它占用4个字节。
};
//所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为sizeof(double)=8的倍数。

```



## 常用类型对齐方式

（变量存放的起始地址相对于结构的起始地址的偏移量） 

- Char 
  偏移量必须为sizeof(char)即1的倍数 
- int 
  偏移量必须为sizeof(int)即4的倍数 
- float 
  偏移量必须为sizeof(float)即4的倍数 
- double 
  偏移量必须为sizeof(double)即8的倍数 
- Short 
  偏移量必须为sizeof(short)即2的倍数 

各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节GCC会自动填充。同时GCC为了**确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数**，这是为了多个结构同时创建时不用再补充字节了。所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。 

**下面用前面的例子来说明VC到底怎么样来存放结构的。 **

```c++
struct MyStruct 
{ 
double a; 
char b; 
int c 
};
```

为上面的结构分配空间的时候，VC根据成员变量出现的顺序和对齐方式，

(1)先为第一个成员a分配空间，其起始地址跟结构的起始地址相同（刚好偏移量0刚好为sizeof(double)的倍数），该成员变量占用sizeof(double)=8个字节；
(2)接下来为第二个成员b分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为8，是sizeof(char)的倍数，所以把b存放在偏移量为8的地方满足对齐方式，该成员变量占用 sizeof(char)=1个字节；
(3)接下来为第三个成员c分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为9，不是sizeof (int)=4的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这时下一个可以分配的(4)地址对于结构的起始地址的偏移量为12，刚好是sizeof(int)=4的倍数，所以把c存放在偏移量为12的地方，该成员变量占用sizeof(int)=4个字节；
(5)这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以没有空缺的字节需要填充。所以整个结构的大小为：sizeof(MyStruct)=8+1+ 3+4=16，其中有3个字节是VC自动填充的，没有放任何有意义的东西。 

原文链接：https://blog.csdn.net/sweetfather/article/details/78487563