---
title: C++11 新特性
tags: C++
category: CS大学生必备
---

# 关键字

## auto

- 使用auto的时候，编译器根据上下文情况，确定auto变量的真正类型。<font color="red">（必须在定义时初始化）</font>

```c++
 int a=10;
 auto b=a;//自动判断b为int类型
```

### 用法

- 用于代替冗长复杂、变量使用范围专一的变量声明。

```c++
vector<string> v;
    v.push_back("1");
    v.push_back("2");
    for(vector<string>::iterator i=v.begin();i!=v.end();i++){
        cout<<(*i)<<endl;
    }
```

​     使用auto能简化代码

```
vector<string> v;
v.push_back("1");
v.push_back("2");
for(auto i=v.begin();i!=v.end();i++){
    cout<<(*i)<<endl;
}
```

- 在定义模板函数时，用于声明依赖模板参数的变量类型。

模板函数就是在不知道参数的数据类型时可以不进行重载，利用模板函数进行运算。

```c++
template<typename T1,typename T2>//两个数可能是不同类型，所以声明两个模板名
void add(T1 a,T2 b){
    auto c=a+b;
    cout<<(a+b)<<endl;
}
```

模板函数依赖于模板参数的返回值

```c++
template<typename T1,typename T2>//两个数可能是不同类型，所以声明两个模板名
auto add(T1 a,T2 b){
    return a+b;
}
```

## nullptr

NULL是一个宏定义，在c和c++中的定义不同，c中NULL为（void*)0,而c++中NULL为整数0，所以在c++中int *p=NULL; 实际表示将指针P的值赋为0，而c++中当一个指针的值为0时，认为指针为空指针。所以引入nullptr，专门用来区分0、NULL。

```c++
void fun(int i){cout<<"1";};
void fun(char *p){cout<<"2";};
int main()
{
fun(NULL);  //输出1，c++中NULL为整数0
fun(nullptr);//输出2，nullptr 为空指针常量。是指针类型
}
```

## for循环

结合auto的用法

- string

```c++
string str = "this is a string";
   for(auto ch : str)
        cout << ch << endl;
```

- vector

```c++
vector<int> v = {1, 2, 3, 4, 5};
   for(auto i : v)
    cout << i << endl;
```

- 二维vector

```c++
vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
   for(auto i : v)
    for(auto j : i)
        cout << j << endl;
```

- 数组

```c++
int ary[] = {1, 2, 3, 4, 5};
   for(auto i : ary)
        cout << i << endl;
```

- map

```c++
map<char, int> m = {{'a', 1}, {'b', 2}, {'c', 3}};
   for(auto t : m)
    cout << t.first << ' ' << t.second << endl;
```

等价于

```c++
for(map<char, int> :: iterator itr = m.begin(); itr != m.end(); itr++)
    cout << itr ->first << ' ' << itr ->second << endl;
```

# STL容器

## array

```c++
array<int,5> a;
for(int i=0;i<5;i++)
      a[i]=i;
for(auto i:a)
      cout<<i<<' ';
cout<<a.size()<<endl;
// 0 1 2 3 4 5
```

## forward_list

-  list是双向链表结构，它的数据由若干个节点构成，每一个节点都包括一个信息块（即实际存储的数据）、一个前驱指针和一个后驱指针。
-  forward_list是一个单向链表，只支持单向顺序访问，在链表的任何位置进行插入/删除操作都非常快。
- forward_list和list的区别在于前者是单向链表，在内部元素只有一个链接到下一个元素，它的迭代器是前向有效的；后者是双向链表，在内部存在两个链接，一个链接指向下一个元素，另一个链接指向前面一个元素，它的迭代器是双向有效地，在存储方面list会消耗更多的空间，插入和删除元素会稍微消耗更多的时间。forward_list的迭代器是虽然是单向的，但是它比list效率高。
-  Forward_list与其他标准容器(array、deque、vector)相比较，在容器的任何位置插入、提取、移动元素的效率更高。但是根据位置直接访问元素的操作其他几个容器效率更高。

```c++
forward_list<int> f;
f.push_front(2);
f.push_front(3);
for(auto i:f)
   cout<<i<<' ';
//3 2
```

## unordered_map

与map的使用方法一样，但是map的底层是红黑树，而unoredred_map的底层是用哈希表实现的，速度会比map更快，但是占用的内存更多。而且在存储中是无序的

- map

```c++
map<int,string> mp1={{3,"a"},{1,"b"},{2,"c"}};
for(auto i:mp1)
        cout<<i.first<<' '<<i.second<<endl;
/*
1 b
2 c
3 a
*/
```

- unordered_map

```c++
unordered_map<int,string> mp2={{3,"a"},{1,"b"},{2,"c"}};
for(auto i:mp2)
       cout<<i.first<<' '<<i.second<<endl;
/*
2 c
1 b
3 a
*/
```

## set

- set基于红黑树实现，红黑树具有**自动排序的功能**，因此map内部所有的数据，在任何时候，都是有序的。
- unordered_set,基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，**无自动排序功能**。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用`hash`函数对`key`进行映射到不同区域进行保存。

**以下情况使用set：**

1. 我们需要有序数据（不同的元素）。
2. 我们必须打印/访问数据（按排序顺序）。
3. 我们需要元素的前身/后继者。

**以下情况下使用unordered_set：**

1. 我们需要保留一组不同的元素，不需要排序。
2. 我们需要单个元素访问，即没有遍历。

- set

````c++
set<int> s1;
s1.insert(3),s1.insert(1),s1.insert(2);
for(auto i:s1)
    cout<<i<<endl;
/*
1
2
3
*/
````

- unordered_set

```c++
unordered_set<int> s2;
s2.insert(3),s2.insert(1),s2.insert(2);
for(auto i:s2)
    cout<<i<<endl;
/*
2
3
1
*/
```

# 智能指针内存管理