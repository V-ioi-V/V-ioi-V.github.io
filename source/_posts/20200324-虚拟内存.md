---
title: 虚拟内存
tags: 操作系统
category: CS大学生必备
date: 2020/03/24 20:59
---



**1、对于CPU来说，它的目标存储器是物理内存，使用cache做物理内存的缓存**

**2、对于虚拟内存来说，它的目标存储器是磁盘空间，使用物理内存做磁盘的缓存**

<!--more-->

<font size=4>

**名词解释**

虚拟地址(virtual memory)：相对物理地址来说的概念，不真实存在的

物理地址(physical address)：真实存在的，和物理内存关联的

页表(page table)：管理虚拟内存页和物理内存页映射和缓存状态的数据结构

页表条目(page table entry PTE)：是构成页表的基本元素，是索引号为虚拟页号、值为物理页号的数组

地址翻译：将虚拟地址映射成物理地址的过程

页(page)：和存储里块一样，类似的单位；虚拟内存中使用页(**page**)来表示块

虚拟页(VP)：虚拟地址空间划分为多个固定大小的虚拟页

物理页(PP)：物理地址空间划分为多个固定大小的物理页

页表基地址寄存器（PTBR）：CPU有一个专门的页表基地址寄存器，指向当前页表的基地址

翻译后备缓冲区（TLB）：一个用来缓存页表条目PTE的硬件设备

MMU(Memory Management Unit)：内存管理单元，CPU中含有的硬件，将虚拟地址转换为物理地址

## 传统存储管理方式：

​       进程必须一次全部加载到内存中，方可运行。当进程很大，就无法运行。而且多道进程运行时，内存不足容纳所有进程，导致多道程序性能下降。操作系统引入了虚拟内存的概念，利用计算机的空间局部性和时间局部性原理，将程序分的一部分装入内存运行，其余部分留在外存，等需要的时候再将外存的程序装入内存继续运行。

​        例如一台计算机有128M内存，A进程需要10M内存，B进程需要100M内存；操作系统会先将内存中的前 10M 分配给程序 A ，接着再从内存中剩余的 118M 中划分出 110M 分配给程序 B ；如果这时候又运行了需要20M程序 C，系统只剩下 8M 的空间可供使用，此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。

虚拟内存好像给用户提供了一个比实际内存大得多的存储器。叫虚拟存储器，大小由计算机地址结构决定。

- 缺点：

  1、进程的内存地址空间不隔离，有安全隐患

  2、内存效率使用率低；当内存不够时，需要和磁盘进行交互

  3、程序运行地址不确定。我想这个会降低CPU cache命中率

## 虚拟内存

### 分段

- 按照程序固有的段的大小来划分，每个程序有一个段表。

**解决地址隔离和地址不确定问题，如何实现的？**

所有计算机科学中的问题都能通过增加一个中间转换层来解决，虚拟内存就是中间层的存在；

程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址；操作系统将这个虚拟地址映射到适当的物理内存地址上；然后把程序全部装入内存；通过映射机制，当程序访问虚拟地址空间上的某个地址值时，就相当于访问了物理地址空间中的另一个值

当进程创建时，每个进程都会有一个自己的 4GB 虚拟地址空间。要注意的是这个 4GB 的地址空间是“虚拟”的，并不是真实存在的，而且**每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据**，通过这种方法实现了进程间的地址隔离

### 分页

**解决内存效率使用问题，如何实现的？**

每个进程都拥有4GB空间，很显然这会超过物理内存空间；而分页的思想是在分段的基础上，程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。

而虚拟地址和物理地址之间的映射关系是存储在页表中的；页表类似路由表，里面包含一条条虚拟页与物理页的映射关系的条目，页表条目是个数组，索引号对应着虚拟页号，值对应着物理页号和有效位，权限控制位(控制可读，可写，是否需要root权限)

![v2-9cdb01e6e7737431fc3adf15d18881db_720w.jpg](https://i.loli.net/2020/03/24/HPCqWFp9JIDn6MN.jpg)

如图：

有效位为1的时候表示虚拟页已经缓存。

有效位为0，数组值为null时，表示未分配的页。

有效位为0，数组值不为null，表示已经分配了虚拟页，但是还未缓存到具体的物理页中（缺页）

注意这里的缓存是代表内存中存有数据。

- 在使用虚拟页式存储管理时需要在页表中增加一些内容：

**页号、驻留位（中断位）、内存块号、外存地址、访问号、修改位**

**驻留位：表示该页在外存还是内存；**

**访问位：表示该页在内存期间是否被访问过，又称R位；**

**修改位：表示该页在内存中是否被修改过，又称M位；**

### 页表缓存

页表是被缓存在内存中的，为了防止每次地址翻译操作都需要去访问内存，**CPU**使用了高速缓存与**TLB**来缓存**PTE**。**TLB**是**MMU**中的一个缓冲区，其中每一行都保存着一个由单个**PTE**组成的块

页表由操作系统管理，并且MMU需要借助存放在内存中的页表来动态翻译虚拟地址

### 缺页

**虚拟页没有被缓存在物理内存中**（缓存未命中）被称为缺页。

当CPU遇见缺页时会触发一个缺页异常，缺页异常将控制权转向操作系统内核，然后调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果牺牲页已被修改过，内核会先将它复制回硬盘（采用写回机制而不是直写也是为了尽量减少对硬盘的访问次数），然后再把该虚拟页覆盖到牺牲页的位置，并且更新PTE。

缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：

1、保护CPU现场

2、分析中断原因

3、转入缺页中断处理程序进行处理

4、恢复CPU现场，继续执行

### 地址翻译

地址翻译原理：

![2.jpg](https://i.loli.net/2020/03/24/8eD1WsvRTxcuLHd.jpg)

n位的虚拟地址划分为p位的虚拟地址偏移量VPO和(n - p)位的虚拟页号VPN;

**MMU**根据**VPN**来选择对应的**PTE**，例如VPN 0代表PTE 0、VPN 1代表PTE 1….因为物理页与虚拟页的大小是一致的，所以物理页面偏移量（Physical Page Offset, PPO）与VPO是相同的，那么之后只要将**PTE**中的物理页号（**Physical Page Number**, **PPN**）与虚拟地址中的**VPO**串联起来，就能得到相应的物理地址。

地址翻译过程：

![3.jpg](https://i.loli.net/2020/03/24/4FkNh5PztXeMSqy.jpg)

1. CPU拿到一个虚拟地址，分为两步，先通过页表机制确定该地址所在虚拟页的内容是否从磁盘加载到物理内存页中，然后通过高速缓存机制从该物理地址中取到数据

2. 地址翻译硬件要把这个虚拟地址翻译成一个物理地址，从而可以再根据高速缓存的映射关系，把这个物理地址对应的值找到

3. 地址翻译硬件利用页表数据结构，TLB硬件缓存等技术，目的只是把一个虚拟地址映射到一个物理地址。要记住DRAM缓存是全相联的，所以一个虚拟地址和一个物理地址是动态关联的，不能直接根据虚拟地址推导出物理地址，必须根据DRAM从磁盘把数据缓存到DRAM时存到页表时存的实际物理页才能得到实际的物理地址，用物理页PPN + VPO就能算出实际的物理地址 (VPO = PPO，所以直接用VPO即可)。 PPN的值是存在页表条目PTE中的。地址翻译做了一堆工作，就是为了找到物理页PPN，然后根据VPO页面偏移量，就能定位到实际的物理地址。

4. 得到实际物理地址后，根据高速缓存的原理，把一个物理地址映射到高速缓存具体的组，行，块中，找到实际存储的数据。

## 虚拟内存实现方式：

（请求分页，请求分段，请求段页式存储管理）

### 1.请求分页存储管理

将虚拟地址内存空间划分位大小相等的页块，同时内存地址空间，也划分位等大小的页块。系统维持一个页表，存储这虚拟页号到物理快块号的映射。程序中的逻辑地址由两部分组成：页号P和页内位移量W。相邻的页面在内存中不一定相邻，即分配给程序的内存块之间不一定连续。逻辑地址转化为物理地址时，根据页表将页号转化为块号，块号乘块大小加上页内偏移得到物理地址。

如果程序执行时，调用到不在内存中的虚拟页面时，发生缺页中断，将页由外存调入内存。如果内存已满，采用页面置换算法将老的淘汰，载入新的。页面置换算法常见的有FIFO,LRU。

- 优点：
  - 没有外碎片，每个内碎片不超过页的大小。
  - 页表简单、长度短、所需硬件少，速度快
  - 主存利用率高于段式。
  - 调入调出速度快，内存管理简单
- 缺点：
  - 程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。
  - 机械分割程序，破坏段的独立性，（可能将一个段分成好几个页）

### 2.请求分段存储管理：

将用户程序地址空间分成若干个大小不等的段，每段能够定义一组相对完整的逻辑信息。存储分配时，以段为单位，段内地址连续，段间不连续。虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。 分页对程序猿而言是不可见的。而分段通常对程序猿而言是可见的，因而分段为组织程序和数据提供了方便。

- 优点：

  - 可以分别编写和编译，可以针对不同类型的段采取不同的保护。
  - 可以按段为单位来进行共享，包括通过动态链接进行代码共享。
  - 容易实现以段为单位的存储保护

- 缺点：

  - 各段的长度是任意的，在主存的起点任意，会产生碎片。调入调出速度慢。
  - 段表每行较长，硬件复杂成本高

  - 段间零头大，主存利用率低

### 3.段页式存储组织

段页式存储组织是分段式和分页式结合的存储组织方法。这样可充分利用分段管理和分页管理的长处。 程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。用分页方法来分配和管理实存。用分段方法来分配和管理虚拟存储器。

- 优点：段页式管理是段式管理和页式管理相结合而成，具有两者的优点。

- 缺点：由于管理软件的增加，复杂性和开销也增加。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。

参考自：https://zhuanlan.zhihu.com/p/61238591