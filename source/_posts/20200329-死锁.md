---
title: 操作系统中的死锁
tags: 操作系统
category: CS大学生必备
date: 2020/03/29 17:05
---

<font size=4>

# 死锁

死锁的概念：如果一个进程集合中，每个进程都在等待只能由该集合中其他进程才能引发的事件，那么该进程集合就是死锁的。

死锁并不仅仅发生在资源上，资源死锁只是一种。

## 死锁的四个必要条件

四个条件缺一不可，因此只要避免其中一个条件即可预防死锁

- 1.**互斥条件:**一个资源每次只能给一个进程使用

- 2.**占有和等待条件:**或称为请求和保持，进程在申请新的资源的同时保持对原有资源的占有

- 3.**不可抢占条件:**　或称为不可剥夺，资源申请者不能强行从占有者手中夺取资源，只能由占有者自愿释放

- 4.**环路等待条件:**死锁发生时，系统中一定有由两个或以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。

# 处理死锁的方法

目前处理死锁的方法可以归纳为如下：
1.不考虑此问题（鸵鸟算法）：

把头埋在沙子里，假装根本没发生问题。因为解决死锁问题的代价很高，因此**鸵鸟策略这种不采取任务措施的方案会获得更高的性能**。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

2.不让死锁发生，分为以下两种：

- 死锁预防：不让死锁发生的静态策略，通过设计合适的资源分配算法，由资源分配策略保证不让死锁发生
- 死锁避免：不让死锁发生的动态策略，以不让死锁发生为目标，跟踪并评估资源分配过程，根据评估结果决策是否分配

3.让死锁发生
通过死锁的检测判断死锁是否真的发生，然后采用一些方法来解除死锁的问题。

总体解决锁死发生的方法可以分为四类：**鸵鸟算法、死锁预防、死锁避免以及死锁检测与解除。**

## 死锁预防

在设计系统时，通过确定资源分配算法，排除发生死锁的可能性。具体做法是防止产生死锁的四个必要条件中任何一个条件发生即破坏产生死锁的四个条件之一。

### 1.破坏“互斥使用/资源独占”条件
资源本身的特性是独占的，是排他性使用的，所以要使用一种资源转换技术，**把独占资源变为共享资源**。

### 2.破坏“占有且等待”条件
指一个进程占有了一部分资源，在申请其他资源的时候由于得不到满足而进入等待状态。有下面两种方案实现：

- 实现方案1：**要求每个进程在运行前必须一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配。**这种实现会使得资源的利用率很低，当一个进程所需要的资源不能同时满足的情况下可能一直处于等待状态，会产生饥饿现象。(**饥饿**：由于资源分配策略问题导致某个进程永远无法上CPU运行)
- 实现方案2：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请。

### 3.破坏“不可抢占”条件
实现方案是当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源(两个进程优先级不同)。这种方法具有局限性，适用于状态易于保存和恢复的资源，如CPU、内存资源。

### 4.破坏“循环等待”条件

主要思想是通过定义资源类型的线性顺序实现，实现方案是资源有序分配法，把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配。实现资源的有序分配时需要考虑如何对资源进行编号，通常可以利用资源使用的频繁性进行排序。

假如有P1,P2…Pn共n个进程，每个进程都需要一定的资源，一定可以找到某个进程所需要申请的资源的序号是最大的这个进程，从这个进程开始执行；这个进程执行完之后再继续找下一个所需要资源序号最大的进程，以此类推，因此使用资源的有序分配法一定可以解决死锁问题。

## 死锁避免

死锁避免的设计思想：在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统发生死锁或可能发生死锁，则不予分配，否则予以分配，**即在资源动态分配过程中，防止系统进入不安全状态，以避免死锁的发生**。

- 安全状态：是指系统能够按某种进程推进顺序（P1,P2,…,Pn）为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利的执行完成。其中进程的推进顺序（P1,P2,…,Pn）被称为安全序列。如果系统中能找到这样一个安全序列，则称系统处于安全状态。
- 安全序列：一个进程序列{P1，…，Pn}是安全的，如果对于每一个进程Pi(1≤i≤n），它以后还需要的资源量不超过系统当前剩余资源量与所有进程Pj (j < i )当前占有资源量之和，则称系统处于安全状态。
  **注意：安全状态一定没有死锁发生**。
- 不安全状态：系统中不存在一个安全序列。**不安全状态一定导致死锁**，但是可能目前还没有进入死锁，死锁是不安全状态的一个子集。

安全序列演示，顺序为（B、C、A）

![1.png](https://i.loli.net/2020/03/29/yxbATGFm78cOZfj.png)

（a）B先请求2个，C再请求2个，A再请求3个，还剩下3个

（b）B再请求2个，还剩下1个

（c）B处理完成后释放掉，还剩下5个，C再接着请求

   ...

### 资源轨迹图

如果知道了进程在各个阶段需要哪些资源，那么可以在图中进程标注。两个进程的交叠区域就是一个会造成死锁的区域。进程在图中只能向右或者向上前进，一旦进入了危险区，那么就可能发生死锁。为了避免死锁，应当在合适的时间阻塞某个进程，使得运行避开这个区域。

### 利用银行家算法避免死锁
银行家算法是仿照银行发放贷款时采取的控制方式而设计的一种死锁避免算法，起这样的名字是因为该算法原本是为银行系统设计的，以确保银行在发放贷款时，不会发生不满足客户需要的情况，在操作系统中也可以用它来避免死锁。

为实现银行家算法，每一个进程进入系统时，他它须申明在运行过程中，可能需要每种资源类型的最大数目，其数目不能超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待。

应用条件如下：

- 在固定数量的进程中共享数量固定的资源
- 每个进程预先指定完成工作所需的最大资源数量
- 进程不能申请比系统中可用资源总数还多的资源
- 进程等待资源的时间是有限的
- 如果系统满足了进程对资源的最大需求，那么，进程应该在有限的时间内使用资源，然后归还给系统

## 死锁检测与解除

死锁检测与解除的思想是：允许死锁发生，但是操作系统会不断监视系统进展情况，判断死锁是否真的发生；一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行。

检测死锁是否发生有三个典型的检测时机：

- (1)当进程由于资源请求不满足而等待时检测死锁，缺点是系统开销大；
- (2)定时检测；
- (3)系统资源利用率下降时检测死锁。

**一个简单的死锁检测算法**
给每个进程、每个资源指定唯一编号；设置一张资源分配表记录各进程与其占用资源之间的关系；设置一张进程等待表记录各进程与要申请资源之间的关系。从资源等待表出发，看有没有形成等待的环路。即可以利用资源分配图的思想来检测是否有死锁发生。

**死锁避免**
死锁避免的重要是以最小的代价恢复系统的运行，具体的死锁解除的方法有几个：

- (1)撤消所有死锁进程，代价较大；
- (2)进程回退（Roll back）再启动，进程在执行过程中，系统会为进程记录一些中间节点，当出现死锁的时候进行回退再一起重新运行，由于需要记录每个进程的现场，所以系统代价也比较大；
- (3)按照某种原则逐一撤消死锁进程，直到没有死锁；
- (4)按照某种原则逐一抢占资源（资源被抢占的进程必须回退到之前的对应状态），直到没有死锁。

待补充： 哲学家问题