---
title: TCP可靠传输
tags: 计算机网络原理
category: CS大学生必备
date: 2020/03/19
---

<font size=4>

# TCP结构

![1.png](https://i.loli.net/2020/04/03/X1UKLr2FgISjdTv.png)

- **TCP**，控制传输协议，和UDP的差别很大，它充分实现了数据传输时的各种控制功能：
- 针对发送端发出的数据包的确认应答信号ACK
- 针对数据包丢失或者出现定时器超时的重发机制
- 针对数据包到达接收端主机顺序乱掉的顺序控制
- 针对高效传输数据包的流动窗口控制
- 针对避免网络拥堵时候的流量控制
- 针对刚开始启动的时候避免一下子发送大量数据包而导致网络瘫痪的慢启动算法和拥塞控制。

而这些在UDP中都是没有的！此外，TCP作为一种面向有连接的控制传输协议，只有在确认对端主机存在时才会发送数据，从而可以控制通信流量的浪费。

**TCP通过序列号、检验和、确认应答信号、重发控制、连接管理、窗口控制、流量控制、拥塞控制实现可靠性。**

# TCP 协议如何保证可靠传输

- 应用数据被分割成 TCP 认为最适合发送的数据块。
- TCP 给发送的每一个包进行编号（按照字节分配，每个字节占一个seq），接收方对数据包进行排序（按照每个包的第一个字节的seq），把有序数据传送给应用层。
- **校验和**： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
- TCP 的接收端会丢弃重复的数据。
- **流量控制**： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
- **拥塞控制**： 当网络拥塞时，减少数据的发送。
- **停止等待协议**: 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就- 停止发送，等待对方确认。在收到确认后再发下一个分组。
- **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

------

# TCP数据包的大小以及编号

- TCP所传输的数据的编号不是以报文段来进行编号的，而是将整个传输数据分成单个的字节流，并将每个字节流进行编号。一个TCP数据包中包括多个字节流的数据，而且每个TCP数据报中的数据大小并不一样。在建立TCP连接的三次握手过程中，通信双方各自已确定了初始的序号x和y,TCP每次传送的报文段中的序号字段值表示所要传送本报文中的第一个字节的序号。
- **TCP的确认是对接收到的数据的最高序号的确认**，并向发送端返回一个下次期望收到的第一个数据字节的序号。例如，主机A发送的当前数据序号是400，数据长度是100,则接收端收到后会返回一个确认号是501的确认号给主机A。
- TCP提供的确认机制，可以在通信过程中可以不对每一个TCP数据包发出单独的确认包，而是在传送数据时，顺便把确认信息传出，这样可以大大提高网络的利用率和传输效率。同时，TCP的确认机制，也可以一次确认多个数据报，例如，接收方收到了201，301，401的数据报，则只需要对401的数据包进行确认即可，对401的数据包的确认也意味着401之前的所有数据包都已经确认，这样也可以提高系统的效率。

UDP 包的最大值就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)
TCP 包的最大值就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)

# 滑动窗口（最大值为发送窗口）

滑动窗口=min（拥塞窗口，接受窗口）

- TCP协议的使用
- 每次由接收方传来的大小是按照**字节**来计算的。
- 窗口的大小是由接收方动态控制的
- 维持发送方/接收方缓冲区
  缓冲区是 用来解决网络之间数据不可靠的问题，例如丢包，重复包，出错，乱序

因为TCP处理数据是将数据分割成数据块，所以我们要保证这些数据块到达服务端时的有序性，考虑如何控制有序性？

- **为了保证有序性，我们可以每发一个数据包，收到确认包以后再发出下一个包，这样数据包在服务端一定是有序的。**

但是这样吞吐量（单位时间内成功传送数据的数量）比较低,考虑如何提高吞吐量？

- **我们可以多个包一起发送，然后收到哪个包就返回哪个包的确认。**

但是这样会牺牲有序性，虽然吞吐量提高很多,考虑如何集中上述两个方法的优点？这就要用到**滑动窗口**

**发送方的缓存：**发送完数据包后放入缓存中，收到确认的ACK信号才会释放缓存，否则会从缓存中取出做**超时重传**

**接收方的缓存：**接收数据包以后，按照顺序发送ACK，如果前面的数据没有收到，后面的数据也不能发送ACK

## 实现最优解

> 问题：我们每次需要发多少个包过去呢？发送多少包是最优解呢？

我们能不能把第一个和第二个包发过去后，收到第一个确认包就把第三个包发过去呢？而不是去等到第二个包的确认包才去发第三个包。这样就很自然的产生了我们"滑动窗口"的实现。

![2.png](https://i.loli.net/2020/04/03/gBG1PhmzetqsTxD.png)

在图中，我们可看出灰色1号2号3号包已经发送完毕，并且已经收到Ack。这些包就已经是过去式。4、5、6、7号包是黄色的，表示已经发送了。但是并没有收到对方的Ack，所以也不知道接收方有没有收到。8、9、10号包是绿色的。是我们还没有发送的。这些绿色也就是我们接下来马上要发送的包。 可以看出我们的窗口正好是11格。后面的11-16还没有被读进内存。要等4号-10号包有接下来的动作后，我们的包才会继续往下发送。

### 正常情况

![3.png](https://i.loli.net/2020/04/03/jmnKcoB5PuS4qhx.png)

可以看到4号包对方已经被接收到，所以被涂成了灰色。“窗口”就往右移一格，这里只要保证“窗口”是7格的。 我们就把11号包读进了我们的缓存。进入了“待发送”的状态。8、9号包已经变成了黄色，表示已经发送出去了。接下来的操作就是一样的了，确认包后，窗口往后移继续将未发送的包读进缓存，把“待发送“状态的包变为”已发送“。

### 丢包情况

有可能我们包发过去，对方的Ack丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到Ack。

![4.png](https://i.loli.net/2020/04/03/GhvjYlusfbJoXM6.png)

发生的情况：一直在等Ack。如果一直等不到的话，我们也会把读进缓存的待发送的包也一起发过去。但是，这个时候我们的窗口已经发满了。所以并不能把12号包读进来，而是始终在等待5号包的Ack。

> 如果我们这个Ack始终不来怎么办呢？

### 超时重发

这时候我们有个解决方法：`超时重传`
这里有一点要说明：这个Ack是要按顺序的。必须要等到5的Ack收到，才会把6-11的Ack发送过去。这样就保证了滑动窗口的一个顺序。

![5.png](https://i.loli.net/2020/04/03/TmzqrpZ1ainSBP4.png)

这时候可以看出5号包已经接受到Ack，后面的6、7、8号包也已经发送过去已Ack。窗口便继续向后移动。

## 面试问题：

TCP的可靠性，超时重传怎么实现，M1,M2,M3,M4,M5，丢失M2；怎么重传M2？为什么不用重传M4,M5？

因为每个TCP报文被发送时，都会设置一个重传定时器，若定时期到了还没收到ack包，则应重传。为什么不用重传M4,M5？则可由此文回答：因为采用了累积确认。有例如下：

1.Server 发送80个字节 Part1，seq = 1

2.Server 发送120个字节Part2，Seq = 81

3.Server发送160个字节Part3，Seq = 201，此包由于其他原因丢失

4.Client收到前2个报文段，并发送ACK = 201

5.Server发送140个字节Part4， Seq = 361

6.Server收到Client对于前两个报文段的ACK，将2个报文从窗口中移除，窗口有200个字节的余量

7.报文3的重传定时器到期，没有收到ACK，进行重传

8.这个时候Client已经收到报文4，存放在缓冲区中，也不会发送ACK【累计通知，发送ACK就表示3也收到了】，等待报文3，报文3收到之后，一块对3,4进行确认

9.Server收到确认之后，将报文3,4移除窗口，所有数据发送完成

# 拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变换，叫做拥塞。

## 必背

- 流量控制是在一条TCP连接中的**接收端**采用的措施,用来限制发送端发送报文段的速率,以免在接收端来不及接受,流量控制只控制一个发送端。
- 拥塞控制是用来控制TCP连接中发送端发送报文段的速率,以免过多的数据注入到网络,导致网络奔溃,超过负荷.当发送方发送数据大量的数据会注入到网络,如果没有限制,网络就会超负荷变卡。拥塞控制可能会同时控制多个发送端,限制他们的发送速率。拥塞控制是全局性的。
- 发送窗口的上限值是Min[rwnd,cwnd]。即发送窗口的数值不能超过接受窗口和拥塞窗口中的较小的一个。
- 接受窗口的大小体现了接收端对发送端施加的流量控制,而拥塞窗口的大小则是整个因特网的负载情况对发送端施加的拥塞控制。

## 拥塞控制和流量控制的区别：
拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。

当提供的负载继续增大到某一数值时，网络的吞吐量就下降到零，网络无法工作，产生所谓的死锁。

![4.png](https://i.loli.net/2020/04/03/oBWg9vdDkHU8STp.png) 

## 拥塞控制可以分为开环控制和闭环控制
1.开环控制，在设计网络时把因素考虑到

2.闭环控制，基于反馈环路，使用拥塞的信息来进行调整网络

---------------------------------------------------------------------------------------------------------------------
## 几种拥塞控制方法

![5.png](https://i.loli.net/2020/04/03/7lOsjR8EGmCD2XA.png)

总共四种：慢开始，拥塞避免，快重传，快恢复

### 1.慢开始和拥塞避免

发送方维持一个叫做拥塞窗口cwnd，根据网络来进行动态的调整大小，网络拥塞的时候，路由器会丢弃报文，当发送方没有按时收到确认报文，那么就知道网络发生了拥堵。

现在结合拥塞窗口cwnd的变化来看一下上述两个方法

慢开始的“慢”指的是，初始cwnd=1（此时表示的是报文段的个数，而不是真正传输时使用的字节流）

我们来简单的论一下这个过程：

1.开始时发送方cwnd=1，发送报文段M1，如果收到确认M1，那么此时增大cwnd=2，并发送M2，M3

2.要注意，发送方每收到一个确认报文段，cwnd+1（不包括缺失重传的确认）

也就是说，每经过一个传输伦次（RTT时间），cwnd加倍。

**但是，为了防止拥塞窗口cwnd增长过大而引起网络拥塞，设置一个<font size=5>慢开始门限ssthresh。</font>**

1.当cwnd<ssthresh，使用上述的慢开始算法

2.当cwnd>ssthresh，停止使用慢开始，使用拥塞避免算法

3.当cwnd==ssthresh，两者都可以使用

那么理所当然的，现在我们要来看一下拥塞避免算法。

拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍（也就是收到两个，四个确认，仍然+1），这样cwnd就按线性增大

![6.png](https://i.loli.net/2020/04/03/3qpXDz4nT2ekrJQ.png)

此时我们假设ssthresh为16，也就是超过这个值就要转化为拥塞避免算法，并且假设到24的时候，网络出现拥堵。

此时我们注意两个词：

1.乘法减小：也就是说，当拥塞避免算法增长到24之后，我们更新ssthresh=24/2=12，之后再重新执行之前的两个算法。乘法减小，指的就是ssthresh减半

2.加法增大：指的是，执行拥塞避免算法之后，cwnd线性的进行增长，防止很快就遇到网络拥塞状态

### 2.快重传和快恢复
快重传的核心：针对接收到失序报文的快速重传

当接收方收到了一个失序的报文，马上报告给发送方，我没收到，赶紧重传，假如M2收到了，M3没有收到，之后的M4,M5,M6又发送了，此时接收方一共连续给发送方反馈了4个M2确认报文。那么快重传规定，发送方只要连续收到3个重复确认，立即快重传对方发来的M3。



![7.png](https://i.loli.net/2020/04/03/JnR7QE5qCfwklbB.png)

那么我们再来看一下快恢复

两个要点：

1.当发送方连续收到三个重复确认，执行乘法减小，ssthresh减半

2.由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把cwnd值设置为ssthresh减半之后的值，然后执行拥塞避免算法，线性增大cwnd

![8.png](https://i.loli.net/2020/04/03/VA89H7QUkmTsSKG.png)

 其实呢，对于接收方也是用限额的，有一个rwnd，也就是接收窗口，那么实际上，发送方窗口的上限=min(rwnd,cwnd)

参考文章：https://blog.csdn.net/qq_26896213/article/details/84594060