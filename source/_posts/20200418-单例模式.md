---
title: å•ä¾‹æ¨¡å¼
tags: C++
category: CSå¤§å­¦ç”Ÿå¿…å¤‡
date: 2020/04/18 10:25
---

è½¬è‡ªï¼šhttps://www.cnblogs.com/sunchaothu/p/10389842.html

# C++ å•ä¾‹æ¨¡å¼æ€»ç»“ä¸å‰–æ

å•ä¾‹å¯èƒ½æ˜¯æœ€å¸¸ç”¨çš„ç®€å•çš„ä¸€ç§è®¾è®¡æ¨¡å¼ï¼Œå®ç°æ–¹æ³•å¤šæ ·ï¼Œæ ¹æ®ä¸åŒçš„éœ€æ±‚æœ‰ä¸åŒçš„å†™æ³•; åŒæ—¶å•ä¾‹ä¹Ÿæœ‰å…¶å±€é™æ€§ï¼Œå› æ­¤æœ‰å¾ˆå¤šäººæ˜¯åå¯¹ä½¿ç”¨å•ä¾‹çš„ã€‚æœ¬æ–‡å¯¹C++ å•ä¾‹çš„å¸¸è§å†™æ³•è¿›è¡Œäº†ä¸€ä¸ªæ€»ç»“, åŒ…æ‹¬æ‡’æ±‰å¼ã€çº¿ç¨‹å®‰å…¨ã€å•ä¾‹æ¨¡æ¿ç­‰ï¼› æŒ‰ç…§ä»ç®€å•åˆ°å¤æ‚ï¼Œæœ€ç»ˆå›å½’ç®€å•çš„çš„æ–¹å¼å¾ªåºæ¸è¿›åœ°ä»‹ç»ï¼Œå¹¶ä¸”å¯¹å„ç§å®ç°æ–¹æ³•çš„å±€é™è¿›è¡Œäº†ç®€å•çš„é˜è¿°ï¼Œå¤§é‡ç”¨åˆ°äº†C++ 11çš„ç‰¹æ€§å¦‚æ™ºèƒ½æŒ‡é’ˆ, magic staticï¼Œçº¿ç¨‹é”; ä»å¤´åˆ°å°¾ç†è§£ä¸‹æ¥ï¼Œå¯¹äºå­¦ä¹ å’Œå·©å›ºC++è¯­è¨€ç‰¹æ€§è¿˜æ˜¯å¾ˆæœ‰å¸®åŠ©çš„ã€‚æœ¬æ–‡çš„å…¨éƒ¨ä»£ç åœ¨ g++ 5.4.0 ç¼–è¯‘å™¨ä¸‹ç¼–è¯‘è¿è¡Œé€šè¿‡ï¼Œå¯ä»¥åœ¨[æˆ‘çš„github ä»“åº“](https://github.com/sunchaothu/AdvancedCpp/tree/master/singleton)ä¸­æ‰¾åˆ°ã€‚

## ä¸€ã€ä»€ä¹ˆæ˜¯å•ä¾‹

å•ä¾‹ Singleton æ˜¯è®¾è®¡æ¨¡å¼çš„ä¸€ç§ï¼Œå…¶ç‰¹ç‚¹æ˜¯åªæä¾›**å”¯ä¸€**ä¸€ä¸ªç±»çš„å®ä¾‹,å…·æœ‰å…¨å±€å˜é‡çš„ç‰¹ç‚¹ï¼Œåœ¨ä»»ä½•ä½ç½®éƒ½å¯ä»¥é€šè¿‡æ¥å£è·å–åˆ°é‚£ä¸ªå”¯ä¸€å®ä¾‹;
å…·ä½“è¿ç”¨åœºæ™¯å¦‚ï¼š

1. è®¾å¤‡ç®¡ç†å™¨:ç³»ç»Ÿä¸­å¯èƒ½æœ‰å¤šä¸ªè®¾å¤‡ï¼Œä½†æ˜¯åªæœ‰ä¸€ä¸ªè®¾å¤‡ç®¡ç†å™¨ï¼Œç”¨äºç®¡ç†è®¾å¤‡é©±åŠ¨;
2. æ•°æ®æ± :ç”¨æ¥ç¼“å­˜æ•°æ®çš„æ•°æ®ç»“æ„ï¼Œéœ€è¦åœ¨ä¸€å¤„å†™ï¼Œå¤šå¤„è¯»å–æˆ–è€…å¤šå¤„å†™ï¼Œå¤šå¤„è¯»å–;

## äºŒã€C++å•ä¾‹çš„å®ç°

### 2.1 åŸºç¡€è¦ç‚¹

- å…¨å±€åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼šstatic ç‰¹æ€§ï¼ŒåŒæ—¶ç¦æ­¢ç”¨æˆ·è‡ªå·±å£°æ˜å¹¶å®šä¹‰å®ä¾‹ï¼ˆæŠŠæ„é€ å‡½æ•°è®¾ä¸º privateï¼‰
- çº¿ç¨‹å®‰å…¨
- ç¦æ­¢èµ‹å€¼å’Œæ‹·è´
- ç”¨æˆ·é€šè¿‡æ¥å£è·å–å®ä¾‹ï¼šä½¿ç”¨ static ç±»æˆå‘˜å‡½æ•°

### 2.2 C++ å®ç°å•ä¾‹çš„å‡ ç§æ–¹å¼

#### 2.2.1 æœ‰ç¼ºé™·çš„æ‡’æ±‰å¼

æ‡’æ±‰å¼(Lazy-Initialization)çš„æ–¹æ³•æ˜¯ç›´åˆ°ä½¿ç”¨æ—¶æ‰å®ä¾‹åŒ–å¯¹è±¡ï¼Œä¹Ÿå°±è¯´ç›´åˆ°è°ƒç”¨get_instance() æ–¹æ³•çš„æ—¶å€™æ‰ new ä¸€ä¸ªå•ä¾‹çš„å¯¹è±¡ã€‚å¥½å¤„æ˜¯å¦‚æœè¢«è°ƒç”¨å°±ä¸ä¼šå ç”¨å†…å­˜ã€‚

```cpp
#include <iostream>
// version1:
// with problems below:
// 1. thread is not safe
// 2. memory leak

class Singleton{
private:
    Singleton(){
        std::cout<<"constructor called!"<<std::endl;
    }
    Singleton(Singleton&)=delete;
    Singleton& operator=(const Singleton&)=delete;
    static Singleton* m_instance_ptr;
public:
    ~Singleton(){
        std::cout<<"destructor called!"<<std::endl;
    }
    static Singleton* get_instance(){
        if(m_instance_ptr==nullptr){
              m_instance_ptr = new Singleton;
        }
        return m_instance_ptr;
    }
    void use() const { std::cout << "in use" << std::endl; }
};

Singleton* Singleton::m_instance_ptr = nullptr;

int main(){
    Singleton* instance = Singleton::get_instance();
    Singleton* instance_2 = Singleton::get_instance();
    return 0;
}
```

è¿è¡Œçš„ç»“æœæ˜¯

```txt
constructor called!
```

å¯ä»¥çœ‹åˆ°ï¼Œè·å–äº†ä¸¤æ¬¡ç±»çš„å®ä¾‹ï¼Œå´åªæœ‰ä¸€æ¬¡ç±»çš„æ„é€ å‡½æ•°è¢«è°ƒç”¨ï¼Œè¡¨æ˜åªç”Ÿæˆäº†å”¯ä¸€å®ä¾‹ï¼Œè¿™æ˜¯ä¸ªæœ€åŸºç¡€ç‰ˆæœ¬çš„å•ä¾‹å®ç°ï¼Œä»–æœ‰å“ªäº›é—®é¢˜å‘¢ï¼Ÿ

1. **çº¿ç¨‹å®‰å…¨çš„é—®é¢˜**,å½“å¤šçº¿ç¨‹è·å–å•ä¾‹æ—¶æœ‰å¯èƒ½å¼•å‘ç«æ€æ¡ä»¶ï¼šç¬¬ä¸€ä¸ªçº¿ç¨‹åœ¨ifä¸­åˆ¤æ–­ `m_instance_ptr`æ˜¯ç©ºçš„ï¼Œäºæ˜¯å¼€å§‹å®ä¾‹åŒ–å•ä¾‹;åŒæ—¶ç¬¬2ä¸ªçº¿ç¨‹ä¹Ÿå°è¯•è·å–å•ä¾‹ï¼Œè¿™ä¸ªæ—¶å€™åˆ¤æ–­`m_instance_ptr`è¿˜æ˜¯ç©ºçš„ï¼Œäºæ˜¯ä¹Ÿå¼€å§‹å®ä¾‹åŒ–å•ä¾‹;è¿™æ ·å°±ä¼šå®ä¾‹åŒ–å‡ºä¸¤ä¸ªå¯¹è±¡,è¿™å°±æ˜¯çº¿ç¨‹å®‰å…¨é—®é¢˜çš„ç”±æ¥; **è§£å†³åŠæ³•**:åŠ é”
2. **å†…å­˜æ³„æ¼**. æ³¨æ„åˆ°ç±»ä¸­åªè´Ÿè´£newå‡ºå¯¹è±¡ï¼Œå´æ²¡æœ‰è´Ÿè´£deleteå¯¹è±¡ï¼Œå› æ­¤åªæœ‰æ„é€ å‡½æ•°è¢«è°ƒç”¨ï¼Œææ„å‡½æ•°å´æ²¡æœ‰è¢«è°ƒç”¨;å› æ­¤ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ã€‚**è§£å†³åŠæ³•**ï¼š ä½¿ç”¨å…±äº«æŒ‡é’ˆ;

å› æ­¤ï¼Œè¿™é‡Œæä¾›ä¸€ä¸ªæ”¹è¿›çš„ï¼Œçº¿ç¨‹å®‰å…¨çš„ã€ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆçš„å®ç°;

#### 2.2.2 çº¿ç¨‹å®‰å…¨ã€å†…å­˜å®‰å…¨çš„æ‡’æ±‰å¼å•ä¾‹ ï¼ˆæ™ºèƒ½æŒ‡é’ˆï¼Œé”ï¼‰

```cpp
#include <iostream>
#include <memory> // shared_ptr
#include <mutex>  // mutex

// version 2:
// with problems below fixed:
// 1. thread is safe now
// 2. memory doesn't leak

class Singleton{
public:
    typedef std::shared_ptr<Singleton> Ptr;
    ~Singleton(){
        std::cout<<"destructor called!"<<std::endl;
    }
    Singleton(Singleton&)=delete;
    Singleton& operator=(const Singleton&)=delete;
    static Ptr get_instance(){

        // "double checked lock"
        if(m_instance_ptr==nullptr){
            std::lock_guard<std::mutex> lk(m_mutex);
            if(m_instance_ptr == nullptr){
              m_instance_ptr = std::shared_ptr<Singleton>(new Singleton);
            }
        }
        return m_instance_ptr;
    }


private:
    Singleton(){
        std::cout<<"constructor called!"<<std::endl;
    }
    static Ptr m_instance_ptr;
    static std::mutex m_mutex;
};

// initialization static variables out of class
Singleton::Ptr Singleton::m_instance_ptr = nullptr;
std::mutex Singleton::m_mutex;

int main(){
    Singleton::Ptr instance = Singleton::get_instance();
    Singleton::Ptr instance2 = Singleton::get_instance();
    return 0;
}
```

è¿è¡Œç»“æœå¦‚ä¸‹ï¼Œå‘ç°ç¡®å®åªæ„é€ äº†ä¸€æ¬¡å®ä¾‹ï¼Œå¹¶ä¸”å‘ç”Ÿäº†ææ„ã€‚

```txt
constructor called!
destructor called!
```

shared_ptrå’Œmutexéƒ½æ˜¯C++11çš„æ ‡å‡†ï¼Œä»¥ä¸Šè¿™ç§æ–¹æ³•çš„ä¼˜ç‚¹æ˜¯

- åŸºäº shared_ptr, ç”¨äº†C++æ¯”è¾ƒå€¡å¯¼çš„ RAIIæ€æƒ³ï¼Œç”¨å¯¹è±¡ç®¡ç†èµ„æº,å½“ shared_ptr ææ„çš„æ—¶å€™ï¼Œnew å‡ºæ¥çš„å¯¹è±¡ä¹Ÿä¼šè¢« deleteæ‰ã€‚ä»¥æ­¤é¿å…å†…å­˜æ³„æ¼ã€‚
- åŠ äº†é”ï¼Œä½¿ç”¨äº’æ–¥é‡æ¥è¾¾åˆ°çº¿ç¨‹å®‰å…¨ã€‚è¿™é‡Œä½¿ç”¨äº†ä¸¤ä¸ª ifåˆ¤æ–­è¯­å¥çš„æŠ€æœ¯ç§°ä¸º**åŒæ£€é”**ï¼›å¥½å¤„æ˜¯ï¼Œåªæœ‰åˆ¤æ–­æŒ‡é’ˆä¸ºç©ºçš„æ—¶å€™æ‰åŠ é”ï¼Œé¿å…æ¯æ¬¡è°ƒç”¨ get_instanceçš„æ–¹æ³•éƒ½åŠ é”ï¼Œé”çš„å¼€é”€æ¯•ç«Ÿè¿˜æ˜¯æœ‰ç‚¹å¤§çš„ã€‚

ä¸è¶³ä¹‹å¤„åœ¨äºï¼š ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆä¼šè¦æ±‚ç”¨æˆ·ä¹Ÿå¾—ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œéå¿…è¦ä¸åº”è¯¥æå‡ºè¿™ç§çº¦æŸ; ä½¿ç”¨é”ä¹Ÿæœ‰å¼€é”€; åŒæ—¶ä»£ç é‡ä¹Ÿå¢å¤šäº†ï¼Œå®ç°ä¸Šæˆ‘ä»¬å¸Œæœ›è¶Šç®€å•è¶Šå¥½ã€‚

è¿˜æœ‰æ›´åŠ ä¸¥é‡çš„é—®é¢˜ï¼Œåœ¨æŸäº›å¹³å°ï¼ˆä¸ç¼–è¯‘å™¨å’ŒæŒ‡ä»¤é›†æ¶æ„æœ‰å…³ï¼‰ï¼ŒåŒæ£€é”ä¼šå¤±æ•ˆï¼å…·ä½“å¯ä»¥çœ‹[è¿™ç¯‡æ–‡ç« ](http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726)ï¼Œè§£é‡Šäº†ä¸ºä»€ä¹ˆä¼šå‘ç”Ÿè¿™æ ·çš„äº‹æƒ…ã€‚

å› æ­¤è¿™é‡Œè¿˜æœ‰ç¬¬ä¸‰ç§çš„åŸºäº Magic Staicçš„æ–¹æ³•è¾¾åˆ°çº¿ç¨‹å®‰å…¨

#### 2.2.3 æœ€æ¨èçš„æ‡’æ±‰å¼å•ä¾‹(magic static )â€”â€”å±€éƒ¨é™æ€å˜é‡

```cpp
#include <iostream>

class Singleton
{
public:
    ~Singleton(){
        std::cout<<"destructor called!"<<std::endl;
    }
    Singleton(const Singleton&)=delete;
    Singleton& operator=(const Singleton&)=delete;
    static Singleton& get_instance(){
        static Singleton instance;
        return instance;

    }
private:
    Singleton(){
        std::cout<<"constructor called!"<<std::endl;
    }
};

int main(int argc, char *argv[])
{
    Singleton& instance_1 = Singleton::get_instance();
    Singleton& instance_2 = Singleton::get_instance();
    return 0;
}
```

è¿è¡Œç»“æœ

```txt
constructor called!
destructor called!
```

è¿™ç§æ–¹æ³•åˆå«åš Meyers' Singleton[Meyer'sçš„å•ä¾‹](https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method-is-it-thre/449823#449823)ï¼Œ æ˜¯è‘—åçš„å†™å‡ºã€ŠEffective C++ã€‹ç³»åˆ—ä¹¦ç±çš„ä½œè€… Meyers æå‡ºçš„ã€‚æ‰€ç”¨åˆ°çš„ç‰¹æ€§æ˜¯åœ¨C++11æ ‡å‡†ä¸­çš„[Magic Static](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm)ç‰¹æ€§ï¼š

> If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.
> å¦‚æœå½“å˜é‡åœ¨åˆå§‹åŒ–çš„æ—¶å€™ï¼Œå¹¶å‘åŒæ—¶è¿›å…¥å£°æ˜è¯­å¥ï¼Œå¹¶å‘çº¿ç¨‹å°†ä¼šé˜»å¡ç­‰å¾…åˆå§‹åŒ–ç»“æŸã€‚

è¿™æ ·ä¿è¯äº†å¹¶å‘çº¿ç¨‹åœ¨è·å–é™æ€å±€éƒ¨å˜é‡çš„æ—¶å€™ä¸€å®šæ˜¯åˆå§‹åŒ–è¿‡çš„ï¼Œæ‰€ä»¥å…·æœ‰çº¿ç¨‹å®‰å…¨æ€§ã€‚

[C++é™æ€å˜é‡çš„ç”Ÿå­˜æœŸ](https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function) æ˜¯ä»å£°æ˜åˆ°ç¨‹åºç»“æŸï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§æ‡’æ±‰å¼ã€‚

**è¿™æ˜¯æœ€æ¨èçš„ä¸€ç§å•ä¾‹å®ç°æ–¹å¼ï¼š**

1. é€šè¿‡å±€éƒ¨é™æ€å˜é‡çš„ç‰¹æ€§ä¿è¯äº†çº¿ç¨‹å®‰å…¨ (C++11, GCC > 4.3, VS2015æ”¯æŒè¯¥ç‰¹æ€§);
2. ä¸éœ€è¦ä½¿ç”¨å…±äº«æŒ‡é’ˆï¼Œä»£ç ç®€æ´ï¼›
3. æ³¨æ„åœ¨ä½¿ç”¨çš„æ—¶å€™éœ€è¦å£°æ˜å•ä¾‹çš„å¼•ç”¨ `Single&` æ‰èƒ½è·å–å¯¹è±¡ã€‚

å¦å¤–ç½‘ä¸Šæœ‰äººçš„å®ç°è¿”å›æŒ‡é’ˆè€Œä¸æ˜¯è¿”å›å¼•ç”¨

```
static Singleton* get_instance(){
    static Singleton instance;
    return &instance;
}
```

è¿™æ ·åšå¹¶ä¸å¥½ï¼Œç†ç”±ä¸»è¦æ˜¯æ— æ³•é¿å…ç”¨æˆ·ä½¿ç”¨`delete instance`å¯¼è‡´å¯¹è±¡è¢«æå‰é”€æ¯ã€‚è¿˜æ˜¯å»ºè®®å¤§å®¶ä½¿ç”¨è¿”å›å¼•ç”¨çš„æ–¹å¼ã€‚

#### 2.2.4 å‡½æ•°è¿”å›å¼•ç”¨

æœ‰äººåœ¨ç½‘ä¸Šæä¾›äº†è¿™æ ·ä¸€ç§å•ä¾‹çš„å®ç°æ–¹å¼ï¼›

```cpp
#include <iostream>

class A
{
public:
    A() {
        std::cout<<"constructor" <<std::endl;
    }
    ~A(){
        std::cout<<"destructor"<<std::endl;
    }
};


A& ret_singleton(){
    static A instance;
    return instance;
}

int main(int argc, char *argv[])
{
    A& instance_1 = ret_singleton();
    A& instance_2 = ret_singleton();
    return 0;
}
```

ä¸¥æ ¼æ¥è¯´ï¼Œè¿™ä¸å±äºå•ä¾‹äº†ï¼Œå› ä¸ºç±»Aåªæ˜¯ä¸ªå¯»å¸¸çš„ç±»ï¼Œå¯ä»¥è¢«å®šä¹‰å‡ºå¤šä¸ªå®ä¾‹ï¼Œä½†æ˜¯äº®ç‚¹åœ¨äºæä¾›äº†`ret_singleton`çš„æ–¹æ³•ï¼Œå¯ä»¥è¿”å›ä¸€ä¸ªå…¨å±€ï¼ˆé™æ€ï¼‰å˜é‡ï¼Œèµ·åˆ°ç±»ä¼¼å•ä¾‹çš„æ•ˆæœï¼Œè¿™è¦æ±‚ç”¨æˆ·å¿…é¡»ä¿è¯æƒ³è¦è·å– å…¨å±€å˜é‡A ï¼Œåªé€šè¿‡ret_singleton()çš„æ–¹æ³•ã€‚

ä»¥ä¸Šæ˜¯å„ç§æ–¹æ³•å®ç°å•ä¾‹çš„ä»£ç å’Œè¯´æ˜ï¼Œè§£é‡Šäº†å„ç§æŠ€æœ¯å®ç°çš„åˆè¡·å’ŒåŸå› ã€‚è¿™é‡Œä¼š**æ¯”è¾ƒæ¨è C++11 æ ‡å‡†ä¸‹çš„ 2.2.3 çš„æ–¹å¼**ï¼Œå³**ä½¿ç”¨static localçš„æ–¹æ³•**ï¼Œç®€å•çš„ç†ç”±æ¥è¯´æ˜¯å› ä¸ºå…¶è¶³å¤Ÿç®€å•å´æ»¡è¶³æ‰€æœ‰éœ€æ±‚å’Œé¡¾è™‘ã€‚

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç³»ç»Ÿä¸­å¯èƒ½æœ‰å¤šä¸ªå•ä¾‹ï¼Œå¦‚æœéƒ½æŒ‰ç…§è¿™ç§æ–¹å¼çš„è¯ï¼Œå®é™…ä¸Šæ˜¯ä¸€ç§é‡å¤ï¼Œæœ‰æ²¡æœ‰ä»€ä¹ˆæ–¹æ³•å¯ä»¥åªå®ç°ä¸€æ¬¡å•ä¾‹è€Œèƒ½å¤Ÿå¤ç”¨å…¶ä»£ç ä»è€Œå®ç°å¤šä¸ªå•ä¾‹å‘¢ï¼Ÿ å¾ˆè‡ªç„¶çš„æˆ‘ä»¬ä¼šè€ƒè™‘ä½¿ç”¨æ¨¡æ¿æŠ€æœ¯æˆ–è€…ç»§æ‰¿çš„æ–¹æ³•ï¼Œ
åœ¨æˆ‘çš„åšå®¢ä¸­æœ‰ä»‹ç»è¿‡å¦‚ä½•ä½¿ç”¨å•ä¾‹çš„æ¨¡æ¿ã€‚

### 2.3 å•ä¾‹çš„æ¨¡æ¿

#### 2.3.1 CRTP å¥‡å¼‚é€’å½’æ¨¡æ¿æ¨¡å¼å®ç°

ä»£ç ç¤ºä¾‹å¦‚ä¸‹ï¼š

```cpp
// brief: a singleton base class offering an easy way to create singleton
#include <iostream>

template<typename T>
class Singleton{
public:
    static T& get_instance(){
        static T instance;
        return instance;
    }
    virtual ~Singleton(){
        std::cout<<"destructor called!"<<std::endl;
    }
    Singleton(const Singleton&)=delete;
    Singleton& operator =(const Singleton&)=delete;
protected:
    Singleton(){
        std::cout<<"constructor called!"<<std::endl;
    }

};
/********************************************/
// Example:
// 1.friend class declaration is requiered!
// 2.constructor should be private


class DerivedSingle:public Singleton<DerivedSingle>{
   // !!!! attention!!!
   // needs to be friend in order to
   // access the private constructor/destructor
   friend class Singleton<DerivedSingle>;
public:
   DerivedSingle(const DerivedSingle&)=delete;
   DerivedSingle& operator =(const DerivedSingle&)= delete;
private:
   DerivedSingle()=default;
};

int main(int argc, char* argv[]){
    DerivedSingle& instance1 = DerivedSingle::get_instance();
    DerivedSingle& instance2 = DerivedSingle::get_instance();
    return 0;
}
```

ä»¥ä¸Šå®ç°ä¸€ä¸ªå•ä¾‹çš„æ¨¡æ¿åŸºç±»ï¼Œä½¿ç”¨æ–¹æ³•å¦‚ä¾‹å­æ‰€ç¤ºæ„ï¼Œå­ç±»éœ€è¦**å°†è‡ªå·±ä½œä¸ºæ¨¡æ¿å‚æ•°T** ä¼ é€’ç»™ `Singleton` æ¨¡æ¿; åŒæ—¶éœ€è¦**å°†åŸºç±»å£°æ˜ä¸ºå‹å…ƒ**ï¼Œè¿™æ ·æ‰èƒ½è°ƒç”¨å­ç±»çš„ç§æœ‰æ„é€ å‡½æ•°ã€‚

åŸºç±»æ¨¡æ¿çš„å®ç°è¦ç‚¹æ˜¯ï¼š

1. æ„é€ å‡½æ•°éœ€è¦æ˜¯ **protected**ï¼Œè¿™æ ·å­ç±»æ‰èƒ½ç»§æ‰¿ï¼›
2. ä½¿ç”¨äº†[å¥‡å¼‚é€’å½’æ¨¡æ¿æ¨¡å¼](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern)CRTP(Curiously recurring template pattern)
3. get instance æ–¹æ³•å’Œ 2.2.3 çš„static localæ–¹æ³•ä¸€ä¸ªåŸç†ã€‚
4. åœ¨è¿™é‡ŒåŸºç±»çš„ææ„å‡½æ•°å¯ä»¥ä¸éœ€è¦ virtual ï¼Œå› ä¸ºå­ç±»åœ¨åº”ç”¨ä¸­åªä¼šç”¨ Derived ç±»å‹ï¼Œä¿è¯äº†ææ„æ—¶å’Œæ„é€ æ—¶çš„ç±»å‹ä¸€è‡´

#### 2.3.2 ä¸éœ€è¦åœ¨å­ç±»å£°æ˜å‹å…ƒçš„å®ç°æ–¹æ³•

åœ¨ [stackoverflow](https://codereview.stackexchange.com/questions/173929/modern-c-singleton-template)ä¸Šï¼Œ æœ‰å¤§ç¥ç»™å‡ºäº†**ä¸éœ€è¦åœ¨å­ç±»ä¸­å£°æ˜å‹å…ƒçš„æ–¹æ³•**ï¼Œåœ¨è¿™é‡Œä¸€å¹¶æ”¾å‡º;ç²¾é«“åœ¨äºä½¿ç”¨ä¸€ä¸ªä»£ç†ç±» tokenï¼Œå­ç±»æ„é€ å‡½æ•°éœ€è¦ä¼ é€’tokenç±»æ‰èƒ½æ„é€ ï¼Œä½†æ˜¯æŠŠ tokenä¿æŠ¤å…¶èµ·æ¥ï¼Œ ç„¶åå­ç±»çš„æ„é€ å‡½æ•°å°±å¯ä»¥æ˜¯å…¬æœ‰çš„äº†ï¼Œè¿™ä¸ªå­ç±»åªæœ‰ `Derived(token)`çš„è¿™æ ·çš„æ„é€ å‡½æ•°ï¼Œè¿™æ ·ç”¨æˆ·å°±æ— æ³•è‡ªå·±å®šä¹‰ä¸€ä¸ªç±»çš„å®ä¾‹äº†ï¼Œèµ·åˆ°æ§åˆ¶å…¶å”¯ä¸€æ€§çš„ä½œç”¨ã€‚ä»£ç å¦‚ä¸‹ã€‚

```cpp
// brief: a singleton base class offering an easy way to create singleton
#include <iostream>

template<typename T>
class Singleton{
public:
    static T& get_instance() noexcept(std::is_nothrow_constructible<T>::value){
        static T instance{token()};
        return instance;
    }
    virtual ~Singleton() =default;
    Singleton(const Singleton&)=delete;
    Singleton& operator =(const Singleton&)=delete;
protected:
    struct token{}; // helper class
    Singleton() noexcept=default;
};


/********************************************/
// Example:
// constructor should be public because protected `token` control the access


class DerivedSingle:public Singleton<DerivedSingle>{
public:
   DerivedSingle(token){
       std::cout<<"destructor called!"<<std::endl;
   }

   ~DerivedSingle(){
       std::cout<<"constructor called!"<<std::endl;
   }
   DerivedSingle(const DerivedSingle&)=delete;
   DerivedSingle& operator =(const DerivedSingle&)= delete;
};

int main(int argc, char* argv[]){
    DerivedSingle& instance1 = DerivedSingle::get_instance();
    DerivedSingle& instance2 = DerivedSingle::get_instance();
    return 0;
}
```

#### 2.3.3 å‡½æ•°æ¨¡æ¿è¿”å›å¼•ç”¨

åœ¨ 2.2.4 ä¸­æä¾›äº†ä¸€ç§ç±»å‹çš„å…¨å±€å˜é‡çš„æ–¹æ³•ï¼Œå¯ä»¥æŠŠä¸€ä¸ªä¸€èˆ¬çš„ç±»ï¼Œé€šè¿‡è¿™ç§æ–¹å¼æä¾›ä¸€ä¸ªç±»ä¼¼å•ä¾‹çš„
å…¨å±€æ€§æ•ˆæœï¼ˆä½†æ˜¯ä¸èƒ½é˜»æ­¢ç”¨æˆ·è‡ªå·±å£°æ˜å®šä¹‰è¿™æ ·çš„ç±»çš„å¯¹è±¡ï¼‰;åœ¨è¿™é‡Œæˆ‘ä»¬æŠŠè¿™ä¸ªæ–¹æ³•å˜æˆä¸€ä¸ª template æ¨¡æ¿å‡½æ•°ï¼Œç„¶åå°±å¯ä»¥å¾—åˆ°ä»»ä½•ä¸€ä¸ªç±»çš„å…¨å±€å˜é‡ã€‚

```cpp
#include <iostream>

class A
{
public:
    A() {
        std::cout<<"constructor" <<std::endl;
    }
    ~A(){
        std::cout<<"destructor"<<std::endl;
    }
};

template<typename T>
T& get_global(){
    static T instance;
    return instance;
}

int main(int argc, char *argv[])
{
    A& instance_1 = get_global<A>();
    A& instance_2 = get_global<A>();
    return 0;
}
```

å¯ä»¥çœ‹åˆ°è¿™ç§æ–¹å¼ç¡®å®éå¸¸ç®€æ´ï¼ŒåŒæ—¶ç±»ä»ç„¶å…·æœ‰ä¸€èˆ¬ç±»çš„ç‰¹ç‚¹è€Œä¸å—é™åˆ¶ï¼Œå½“ç„¶ä¹Ÿå› æ­¤å¤±å»äº†å•ä¾‹é‚£ä¹ˆå¼ºçš„çº¦æŸï¼ˆç¦æ­¢èµ‹å€¼ã€æ„é€ å’Œæ‹·è´æ„é€ ï¼‰ã€‚
è¿™é‡ŒæŠŠå‡½æ•°å‘½åä¸º `get_global()` æ˜¯ä¸ºäº†å¼ºè°ƒï¼Œè¿™é‡Œå¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼è·å–å¾—åˆ°å•ä¾‹æœ€é‡è¦çš„å…¨å±€å˜é‡ç‰¹æ€§ï¼›ä½†æ˜¯å¹¶ä¸æ˜¯å•ä¾‹çš„æ¨¡å¼ã€‚

## ä¸‰ã€ä½•æ—¶åº”è¯¥ä½¿ç”¨æˆ–è€…ä¸ä½¿ç”¨å•ä¾‹

æ ¹æ®stackoverflowä¸Šçš„ä¸€ä¸ªé«˜ç¥¨ç­”æ¡ˆ [singleton-how-should-it-be-used](https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used)ï¼š

> You need to have one and only one object of a type in system
> ä½ éœ€è¦ç³»ç»Ÿä¸­åªæœ‰**å”¯ä¸€**ä¸€ä¸ªå®ä¾‹å­˜åœ¨çš„ç±»çš„**å…¨å±€**å˜é‡çš„æ—¶å€™æ‰ä½¿ç”¨å•ä¾‹ã€‚

- å¦‚æœä½¿ç”¨å•ä¾‹ï¼Œåº”è¯¥ç”¨ä»€ä¹ˆæ ·å­çš„

> How to create the best singleton:
>
> - The smaller, the better. I am a minimalist
> - Make sure it is thread safe
> - Make sure it is never null
> - Make sure it is created only once
> - Lazy or system initialization? Up to your requirements
> - Sometimes the OS or the JVM creates singletons for you (e.g. in Java every class definition is a singleton)
> - Provide a destructor or somehow figure out how to dispose resources
> - Use little memory
>   è¶Šå°è¶Šå¥½ï¼Œè¶Šç®€å•è¶Šå¥½ï¼Œçº¿ç¨‹å®‰å…¨ï¼Œå†…å­˜ä¸æ³„éœ²

### åå¯¹å•ä¾‹çš„ç†ç”±

å½“ç„¶ç¨‹åºå‘˜æ˜¯åˆ†æµæ´¾çš„ï¼Œæœ‰äº›æ˜¯åå¯¹å•ä¾‹çš„ï¼Œæœ‰äº›äººæ˜¯åå¯¹è®¾è®¡æ¨¡å¼çš„ï¼Œæœ‰äº›äººç”šè‡³è¿é¢å‘å¯¹è±¡éƒ½åå¯¹ ğŸ˜ƒ.

åå¯¹å•ä¾‹çš„ç†ç”±æœ‰å“ªäº›ï¼š

## å‚è€ƒæ–‡ç« 

åœ¨æœ¬æ–‡å†™ä½œçš„è¿‡ç¨‹ä¸­å‚è€ƒäº†ä¸€äº›åšå®¢å’Œstackoverflow çš„å›ç­”ï¼Œä»¥è¶…é“¾æ¥çš„æ–¹å¼ä½“ç°åœ¨æ–‡ä¸­ã€‚å¦å¤–è¿˜æœ‰ä¸€äº›æˆ‘è§‰å¾—éå¸¸ç²¾å½©çš„å›ç­”ï¼Œæ”¾åœ¨ä¸‹é¢ä¾›è¯»è€…æ‹“å±•é˜…è¯»

æ¨èé˜…è¯»ï¼š

1. é«˜ç¥¨å›ç­”ä¸­æä¾›äº†ä¸€ç³»åˆ—æœ‰ç›Šçš„é“¾æ¥(https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289)
2. é¢è¯•ä¸­çš„å•ä¾‹(http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html)
3. ä¸€äº›è§‚ç‚¹(https://segmentfault.com/q/1010000000593968)