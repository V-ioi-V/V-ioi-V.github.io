---
title: C++三大特性
tags: C++
category: CS大学生必备 
---

**C++ 三大特性 封装，继承，多态**

<!--more-->

# 封装

- 在C++中，比较狭隘的解释就是将数据与操作数据的方法放在一个类中，而后给每个成员设置相应的权限。**从大一点的角度来说，封装就是将完成一个功能所需要的所有东西放在一起，对外部只开放调用它的接口。**

-  对软件设计或其他工程设计，特别是比较复杂的工程，一般都是模块化设计。模块化设计的好处就是可以将一个复杂的系统拆分成不同的模块。每一个模块又可以独立的设计，调试，这就让多人一起做一个复杂的工程成为现实。如果想做到模块化设计，封装是不可缺少的一部分。一个好的模块，比如一块inter的CPU芯片，它有强大的功能，虽然我们不知道它内部是如何实现的，但却可以很好的使用它。 

| 修饰符        | 当前类 | 同package | 子孙类 | 其他package |
| ------------- | ------ | --------- | ------ | ----------- |
| public        | √      | √         | √      | √           |
| protected     | √      | √         | √      | ×           |
| default(默认) | √      | √         | ×      | ×           |
| private       | √      | ×         | ×      | ×           |

- public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用

- private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用。
- protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。
- 不写的话默认default（friendly）

# 继承

## 定义

继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，可以创建子类对象来调用基类函数，变量等。

很多人说继承可以使代码得到良好的复用，当然这个是继承的一个优点，但代码复用的方法除了继承还有很多，而且有些比继承更好。我认为使用继承最重要的原因是继承可以使整个程序设计更符合人们的逻辑，从而方便的设计出想要表达的意思。比如我们要设计一堆苹果，橘子，梨等水果类，使用面向对象的方法，我们首先会抽象出一个水果的基类，而后继承这个基类，派生出具体的水果类。如果要设计的水果很多，我们还可以在水果基类基础上，继续生成新的基类，比如热带水果类，温带水果类，寒带水果类等，而后再继承这些基类。这样的设计思想就相当于人类的分类思想，简单易懂，而且设计出来的程序层次分明，容易掌握。

 既然继承这么好，那该如何使用继承？

 继承虽好但不能滥用，否则设计出来的程序会杂乱不堪。根据上面的介绍，可以发现继承主要用来定义一个东西是什么，比如热带水果是水果，菠萝是热带水果等，即继承主要用来设计一个程序的类的框架，将所要设计的东西用继承来设立一个基本结构。如果想为一个类添加一个行为或格外的功能，最好是使用组合的方式。如果想了解组合的方式，可以看一下比较著名的策略模式。

## 三种继承方式

三种类型的继承，父类的成员均被子类继承（之前的百科关于这点的描述是错误的），只是由类实例化的对象对其继承的成员的访问权限会有所变化。三种不同方式的继承，描述的是子类实例化对象对其成员的访问权限，并非是描述子类时，子类对继承自父类的成员的访问权限。

- 公有继承 (public)继承自父类的成员保持不变。

- 私有继承(private)继承自父类的成员全部变为私有成员。

- 保护继承 (protected)继承自父类的公有成员变为保护成员，其余不变。

# 多态

## 描述

   多态简单的说就是“一个函数，多种实现”，或是“一个接口，多种方法”。多态性表现在程序运行时根据传入的对象的不同调用不同的函数。

​    C++的动态多态是通过虚函数来实现的，在基类中定义一个函数为虚函数，该函数就可以在运行时，根据传入的对象调用不同的实现方法。而如果该函数不设为虚函数，则在调用的过程中调用的函数就是固定的，此时就是静态多态。

　静态多态与动态多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定，是动态的。

## 静态多态

```c++
class Duck {
public:
    Duck() {}
    ~Duck() {}
    void answer1(){
        std::cout << " I am not a Duck !" <<std::endl;
    }
    void answer2(int m,int n) {
        std::cout << " I am a Duck !" <<std::endl;
    }
};

int main() {
    Duck d;
    d.answer1();
    d.answer2(1,1);
    return 0;
}
/*
I am not a Duck !
I am a Duck !
 */
```

## 虚函数

### 定义

- C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。

- 当子类重新定义了父类的虚函数后，**当父类的指针指向子类对象的地址时**， 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数，且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。

- 如果使用了**virtual**关键字，程序将根据引用或指针指向的 **对 象 类 型** 来选择方法，否则使用**引用类型或指针类型**来选择方法。

### 虚函数的定义要遵循以下重要规则： 

1.如果虚函数在基类与派生类中出现，仅仅是名字相同，而形式参数不同，或者是返回类型不同，那么即使加上了virtual关键字，也是不会进行滞后联编的。 

2.只有类的成员函数才能说明为虚函数，因为虚函数仅适合用与有继承关系的类对象，所以普通函数不能说明为虚函数。

<font color="red">3.静态成员函数不能是虚函数,因为静态成员函数的特点是不受限制于某个对象。 </font>

4.内联(inline)函数不能是虚函数，因为内联函数不能在运行中动态确定位置。即使虚函数在类的内部定义定义，但是在编译的时候系统仍然将它看做是非内联的。

<font color="red">5.析构函数可以是虚函数，在某些情况下必须为虚函数：当一个基类指针指向动态分配的子类对象时，这时如果 delete该基类指针，如果基类的析构函数不是虚函数，那么只会释放基类自己的那部分，而派生类自己的那
部分得不到释放，这是不安全的，如果子类的数据成员部分有动态分配的资源，那么就发生了内存泄漏，但是
可以将基类的析构函数定义为虚析构函数，这样做即使是delete一个指向派生类对象的基类指针，也会先调用派生类的析构函数，再调用父类的析构函数。所以将析构函数设为虚函数总是正确的</font>

<font color="red">5.构造函数不能为虚函数，因为如果对象都没有创建，就无法调用虚函数，构造函数为虚函数是没有任何意义的。</font>

#### 详细版（构造函数不是虚函数）

1.从存储空间角度

​        虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。

2.从使用角度

​        虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。

​        虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

3、构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。

4.从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数 

​        从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数

5.当一个构造函数被调用时，它做的首要的事情之一是初始化它的V P T R。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码- -既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。

​        所以它使用的V P T R必须是对于这个类的V TA B L E。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内， V P T R将保持被初始化为指向这个V TA B L E, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置V P T R指向它的 V TA B L E，等.直到最后的构造函数结束。V P T R的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生 类顺序的另一个理由。

​       但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置V P T R指向它自己的 V TA B L E。如果函数调用使用虚机制，它将只产生通过它自己的V TA B L E的调用，而不是最后的V TA B L E（所有构造函数被调用后才会有最后的V TA B L E）。

## 动态多态

```c++
class Duck {//使用父类指针指向子类对象，调用函数时，调用的就是对应子类的
public:
    Duck() {}
    ~Duck() {}
//定义一个虚函数display
    virtual void display() {
        std::cout << " I am a Duck !" << std::endl;
    }
};

class RedHandDuck : public Duck {
public:
    RedHandDuck() {}
    ~RedHandDuck() {}
//重写display
    virtual void display() {//virtual 可省略不写
        std::cout << " I am a RedHandDuck !" << std::endl;
    }
};

int main() {
    RedHandDuck *duck1=new RedHandDuck();
    Duck *duck2=duck1;
    duck1->display();
    duck2->display();
    return 0;
}
```

使用虚函数virtual

```
 I am a RedHandDuck !
 I am a RedHandDuck !
```

不使用virtual （父类改变不了）

```
I am a RedHandDuck !
I am a Duck !
```

## 思考

​      **多态现在一般的用法，就是拿一个父类的指针去调用子类中被重写的方法。但我搞不懂为什么要那么做，我们直接在子类中写一个同名的成员函数，从而隐藏父类的函数不就行了么？**

- 将父类比喻为电脑的外设接口，子类比喻为外设，现在我有移动硬盘、U盘以及MP3，它们3个都是可以作为存储但是也各不相同。如果我在写驱动的时候，我用个父类表示外设接口，然后在子类中重写父类那个读取设备的虚函数，那这样电脑的外设接口只需要一个。但如果我不是这样做，而是用每个子类表示一个外设接口，那么我的电脑就必须有3个接口分别来读取移动硬盘、U盘以及MP3。若以后我还有SD卡读卡器，那我岂不是要将电脑拆了，焊个SD卡读卡器的接口上去？

- 所以，用父类的指针指向子类，是为了面向接口编程。大家都遵循这个接口，弄成一样的，到哪里都可以用，准确说就是“一个接口，多种实现“。

- 这个解答很有意思！！！