---
title: C++基础知识
tags: C++
category: CS大学生必备
date: 2020/04/15 18:59
---

基础部分整理

<!--more-->

<font size=4>

# 左值右值

左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式).

左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值

- 待补充...

# static

- **全局静态变量**

  在全局变量前加上关键字 static,全局变量就定义成一个全局静态变量.

  - **内存中的位置:**静态存储区,在整个程序运行期间一直存在。

  - **初始化:**未经初始化的全局静态变量会被自动初始化为 0(自动对象的值是任意的,除非他被显式初始化);

  - **作用域:**全局静态变量在声明他的文件之外是不可见的,准确地说是从定义之处开始,到文件结尾。

- **局部静态变量**
  在局部变量之前加上关键字 static,局部变量就成为一个局部静态变量。

  - **内存中的位置: **静态存储区

  - **初始化:**未经初始化的全局静态变量会被自动初始化为 0(自动对象的值是任意的,除非他被显式初始化);

  - **作用域:**作用域仍为局部作用域,当定义它的函数或者语句块结束的时候,作用域结束。但是当局部静态变量离开作用域后,并没有销毁,而是仍然驻留在内存当中,只不过我们不能再对它进行访问,直到该函数再次被调用,并且值不变;

- **静态函数**
  在函数返回类型前加 static,函数就定义为静态函数。函数的定义和声明在默认情况下都是可以extern(外部变量)的,但静态函数只是在声明他的文件当中可见,不能被其他文件所用。函数的实现使用 static 修饰,那么这个函数只可在本 cpp 内使用,不会同其他 cpp 中的同名函数引起冲突;
  **warning:**不要在头文件中声明 static 的全局函数,不要在 cpp 内声明非 static 的全局函数,如果你要在多个 cpp 中复用该函数,就把它的声明提到头文件里去,否则 cpp 内部声明需加上 static 修饰;

- **类的静态成员变量**

  静态成员可以实现多个对象之间的数据共享,并且使用静态数据成员还不会破坏隐藏的原则,即保证了安全性。因此,**静态成员是类的所有对象中共享的成员,而不是某个对象的成员**。对多个对象来说,静态数据成员只存储一处,供所有对象共用。**类的静态成员变量需要在类外分配内存空间。**

- **类的静态成员函数**
  静态成员函数和静态数据成员一样,它们都属于类的静态成员,它们都不是对象成员。因此,对**静态成员的引用可以用类名**。

  在静态成员函数的实现中**不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员**。如果静态成员函数中要引用非静态成员时,可通过对象来引用。从中可看出,调用静态成员函数使用如下格式:<类名>::<静态成员函数名>(<参数表>);

![对比](https://i.loli.net/2020/04/20/VtLxTAYjOHICe8k.png)

**举例如下：**

```c++
#include <bits/stdc++.h>

using namespace std;

class test {
public:
    static int m_value;        //定义私有类的静态成员变量

public:
    test() {
        m_value++;
    }

    static int getValue()        //定义类的静态成员函数
    {
        return m_value;
    }
};

int test::m_value = 0;        //类的静态成员变量需要在类外分配内存空间

int main() {
    test t3;
    cout<<t3.m_value<<endl;
    cout << "test::m_value = " << test::m_value << endl;
    //通过类名直接调用公有静态成员变量，获取对象个数
    cout << "t3.m_value = " << t3.m_value << endl;
    //通过对象名调用公有静态成员变量，获取对象个数
    cout << "test::getValue() = " << test::getValue() << endl;
    //通过类名直接调用公有静态成员函数，获取对象个数
    cout << "t3.getValue() = " << t3.getValue() << endl;
    //通过对象名调用静态成员函数获取对象个数
    return 0;
}
/*
test::m_value = 1
t3.m_value = 1
test::getvalue() = 1
t3.getValue() = 1
*/
```



# this

- 作用就是指向成员函数所作用的对象，所以**非静态成员函数**中可以直接使用this来代表指向该函数作用的对象的指针。
- 静态成员函数中是不能使用this指针，因为静态成员函数相当于是共享的变量，不属于某个对象的变量。

# const

参考链接：https://blog.csdn.net/csdn_chai/article/details/78041050

**具体用法**

| 用法                           | 代码                                                         | 作用                                                         |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| const 变量                     | const int a;                                                 | 不能修改值，必须初始化                                       |
| const 类对象                   | const MyClass a;                                             | 不能修改成员变量的值，**不能调用非 const 函数**              |
| 指向 const 变         量的指针 | const int * a;                                               | 指向内容不可变，指向可变                                     |
| const 指针                     | int * const a;                                               | 指向内容可变，指向不可变                                     |
| 指向 const 变量的 const 指针   | const int * const a;                                         | 指向内容不可变，指向也不可变。const 引用                     |
| const 变量作为函数参数         | void myfun(const int a);                                     | 函数内部不能改变此参数。指向 const 变量的指针做参数，允许上层用一般指针调用。（反之不可） |
| const 返回值                   | const string&  myfun(void);                                  | 用于返回const引用，上层不能使用返回的引用来修改对象          |
| const 成员变量                 | const int a;                                            static const int a; | 必须在初始化列表初始化，之后不能改变。static const成员变量需要单独定义和初始化 |
| const 成员函数                 | void myfun(void) const;                                      | this指针为指向const对象的const指针。不能修改非mutable 的成员变量 |

**注意:**

- const成员方法本质上是使得this指针是指向const对象的指针，所以在const方法内，const 成员函数可以被非const和const对象调用，而const对象只能调用const 成员函数。原因得从C++底层找，C++方法调用时，会传一个隐形的this参数(本质上是对象的地址，形参名为this)进去，所有成员方法的第一个参数是this隐形指针。const成员函数的this指针是指向const对象的const指针，当非const对象调用const方法时，实参this指针的类型是非const对象的const指针，赋给const对象的const指针没有问题；但是如果const对象调用非const方法，此时实参this指针是指向const对象的const指针，无法赋给非const对象的const指针，所以无法调用。注意this实参是放在ecx寄存器中，而不是压入栈中，这是this的特殊之处。在类的非成员函数中如果要用到类的成员变量，就可以通过访问ecx寄存器来得到指向对象的this指针，然后再通过this指针加上成员变量的偏移量来找到相应的成员变量。
- const 指针、指向const的指针和指向const的const指针，涉及到const的特性“const左效、最左右效”
- const 全局变量有内部链接性，即不同的文件可以定义不同的同名const全局变量，使用extern定义可以消除内部链接性，称为类似全局变量，如extern const int a = 10.另一个文件使用extern const int a; 来引用。而且编译器会在编译时，将const变量替换为它的值，类似define那样。

**const 常量和define的区别**

- 作用的阶段： #define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。

- 作用的方式： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 

- 存储方式：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。

- 代码调试的方便程度： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

- const常量存在于程序的**数据段**，#define常量存在于程序的**代码段**

  

**用宏写一个max？**

被字节面试官问到，没明白啥意思所以没写出来，原来是这个意思

```c++
#define MAX(a,b)  (((a)>(b))?(a):(b))
```

# extern（外部变量）

转自：http://blog.csdn.net/xingjiarong/article/details/47656339

利用关键字extern，可以在一个文件中引用另一个文件中定义的变量或者函数。

**一、引用同一个文件中的变量**

```c++
#include<stdio.h>

int func();

int main()
{
    func(); //1
    printf("%d",num); //2
    return 0;
}

int num = 3;

int func()
{
    printf("%d\n",num);
}
```

如果按照这个顺序，变量 num在main函数的后边进行声明和初始化的话，那么在main函数中是不能直接引用num这个变量的，因为当编译器编译到这一句话的时候，找不到num这个变量的声明，但是在func函数中是可以正常使用，因为func对num的调用是发生在num的声明和初始化之后。

如果我不想改变num的声明的位置，但是想在main函数中直接使用num这个变量，怎么办呢？可以使用extern这个关键字。像下面这一段代码，利用extern关键字先声明一下num变量，告诉编译器num这个变量是存在的，但是不是在这之前声明的，你到别的地方找找吧，果然，这样就可以顺利通过编译啦。但是你要是想欺骗编译器也是不行的，比如你声明了extern int num；但是在后面却没有真正的给出num变量的声明，那么编译器去别的地方找了，但是没找到还是不行的。

下面的程序就是利用extern关键字，使用在后边定义的变量。

```c++
#include<stdio.h>

int func();

int main()
{
    func(); //1
    extern int num;
    printf("%d",num); //2
    return 0;
}

int num = 3;

int func()
{
    printf("%d\n",num);
}
```

如果extern这个关键字就这点功能，那么这个关键字就显得多余了，因为上边的程序可以通过将num变量在main函数的上边声明，使得在main函数中也可以使用。
extern这个关键字的真正的作用是引用不在同一个文件中的变量或者函数。

main.c

```c++
#include<stdio.h>

int main()
{
    extern int num;
    printf("%d",num);
    return 0;
}

```

b.c

```c++
#include<stdio.h>

int num = 5;

void func()
{
    printf("fun in a.c");
}

```

例如，这里b.c中定义了一个变量num，如果main.c中想要引用这个变量，那么可以使用extern这个关键字，注意这里能成功引用的原因是，num这个关键字在b.c中是一个**全局变量**，也就是说只有当一个变量是一个全局变量时，extern变量才会起作用，下面这样是不行的。

main.c

```c++
#include<stdio.h>

int main()
{
    extern int num;
    printf("%d",num);
    return 0;
}
```

b.c

```c++
#include<stdio.h>

void func()
{
    int num = 5;
    printf("fun in a.c");
}
```

另外，extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，如果不进行初始化的话，全局变量会被编译器自动初始化为0。像这种写法是不行的。

```c++
extern int num=4;
```

但是在声明之后就可以使用变量名进行修改了，像这样：

```c++
#include<stdio.h>

int main()
{
    extern int num;
    num=1;
    printf("%d",num);
    return 0;
}
```

如果不想这个变量被修改可以使用const关键字进行修饰，写法如下：
mian.c

```c++
#include<stdio.h>

int main()
{
    extern const int num;
    printf("%d",num);
    return 0;
}

```

b.c

```c++
#include<stdio.h>

const int num=5;
void func()
{
    printf("fun in a.c");
}
```

使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全，如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好。

**三、引用另一个文件中的函数**

extern除了引用另一个文件中的变量外，还可以引用另一个文件中的函数，引用方法和引用变量相似。

mian.c

```c++
#include<stdio.h>

int main()
{
    extern void func();
    func();
    return 0;
}
```

b.c

```c++
#include<stdio.h>

const int num=5;
void func()
{
    printf("fun in a.c");
}
```

这里main函数中引用了b.c中的函数func。因为所有的函数都是全局的，所以对函数的extern用法和对全局变量的修饰基本相同，需要注意的就是，需要指明返回值的类型和参数。

# new和malloc

转自：https://www.cnblogs.com/shilinnpu/p/8945637.html

new 是运算符，malloc是库函数

先放一个表格

| 特征               | new/delete                            | malloc/free                          |
| ------------------ | ------------------------------------- | ------------------------------------ |
| 分配内存的位置     | 自由存储区                            | 堆                                   |
| 内存分配成功返回值 | 完整类型指针                          | void* (无类型指针)                   |
| 内存分配失败返回值 | 默认抛出异常                          | 返回NULL                             |
| 分配内存的大小     | 由编译器根据类型计算得出              | 必须显式指定字节数                   |
| 处理数组           | 有处理数组的new版本new[]              | 需要用户计算数组的大小后进行内存分配 |
| 已分配内存的扩充   | 无法直观地处理                        | 使用realloc简单完成                  |
| 是否相互调用       | 可以，看具体的operator new/delete实现 | 不可调用new                          |
| 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器  | 无法通过用户代码进行处理             |
| 函数重载           | 允许                                  | 不允许                               |
| 构造函数与析构函数 | 调用                                  | 不调用                               |

**1.申请内存所在的位置**

new操作符从**自由存储区（free store）**上为对象动态分配内存空间，而malloc函数从**堆**上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

**2.返回类型安全性**

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合**类型安全性**的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*（表示空的指针类型的变量）指针转换成我们需要的类型。
类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。

**3.内存分配失败时的返回值**

new内存分配失败时，会抛出bad_alloc异常，它**不会返回NULL**；malloc分配内存失败时**返回NULL**。

**4.是否需要指定内存大小**

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

```c++
class A{...}
A * ptr = new A;
A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A);
```

**5.是否调用析构函数/构造函数**

使用new操作符来分配对象内存时会经历三个步骤：

- 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，**原始**的，未命名的内存空间以便存储特定类型的对象。
- 第二步：编译器运行相应的**构造函数**以构造对象，并为其传入初值。
- 第三部：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：

- 第一步：调用对象的析构函数。
- 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。

**6.对数组的处理**

C++提供了new[]与delete[]来专门处理数组类型:

```c++
A * ptr = new A[10];//分配10个A对象
```

使用new[]分配的内存必须使用delete[]进行释放：

```c++
delete [] ptr;
```

new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

至于malloc，它并不知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，再给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：

```c++
int * ptr = (int *) malloc( sizeof(int)*10);//分配一个10个int元素的数组
```

**7.new和malloc是否可以相互调用**

operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：

```c++
void * operator new (sieze_t size)
{
    if(void * mem = malloc(size)
        return mem;
    else
        throw bad_alloc();
}
void operator delete(void *mem) noexcept
{
    free(mem);
}
```

**8.是否可以被重载**

opeartor new /operator delete**可以被重载**，而malloc/free并**不允许重载**。

**9.能够直观地重新分配内存**

使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

new没有这样直观的配套设施来扩充内存。

**10. 客户处理内存分配不足**

在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是**new-handler**。new_handler是一个指针类型：

```c++
namespace std
{
    typedef void (*new_handler)();
}
```

指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:

```c++
namespace std
{
    new_handler set_new_handler(new_handler p ) throw();
}
```

set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。

对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。

# 指针

**指针与引用的区别?**

1. 指针是一个变量，它的内容是所指的内存地址，而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

   int a=1;int &b=a;

   一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

2. 指针需要解引用才能访问对象，引用不需要

3. 指针可以不初始化，引用在定义时必须初始化，且以后不可转移引用的对象。

4. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了，从一而终。

5. 指针可以有多级，但是引用只能是一级（int **p合法但是int &&a是不合法的）

6. 指针有const指针，即int* const ptr；而引用没有const，即int& const a 没有,但是有常引用，如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名；

8. 指针变量需要分配栈空间；而引用不需要，仅仅是个别名

9. sizeof(指针)得到指针大小；sizeof(引用)得到对应对象的大小

10. 指针加法和引用加法不一样

11. 引用不需要释放内存空间，在编译时就会优化掉

**多级指针的用处？**

用于组织打包数据，方便描述和传递。比如一位数组，二维数组。 

**指针与数组名的区别?**

1. 数组名不是指针，对数组名取地址，得到整个数组的地址
2. 数组名 + 1会跳过整个数组的大小，指针+1只会跳过一个元素的大小
3. 数组名作为函数参数传递时，退化为指针
4. sizeof(数组名)返回整个数组的大小，sizeof(指针)返回指针大小
5. 数组名无法修改值，是常量
6. int (*p)[] = &arr; 才是正确的数组指针写法

**野指针、空指针的概念?**

1. 访问一个已销毁或者访问受限的内存区域的指针（无效内存），野指针不能判断是否为NULL来避免，不能对野指针取内容。
2. 空指针是指置为0\NULL\nullptr的指针，可以对空指针delete多次。

**char *p和 char p[]的区别？**

https://blog.csdn.net/ngcl_blog/article/details/30508265

char* p是一个指针，根本没分配内存，他指向的"abc123ABC" 是只读的，不能改变，给他赋值肯定是错的而char p[]是一个数组，已经分配内存，是将"abc123ABC" 复制到该内存里面，这个内存是可读写的

# 内存泄露和内存溢出

- 内存泄漏就是内存申请后，用完没有释放，造成可用内存越来越少。

- 内存溢出指用户实际的数据长度超过了申请的内存空间大小，导致覆盖了其他正常数据，容易造成程序异常，严重的，攻击者可以以此获取程序控制权。

# 函数模板

用来解决传参的变量类型的问题,是**参数多态**。

```c++
template <class 类型参数1，class 类型参数2，...>
//template <typename 类型参数1,typename 类型参数2，...>
返回值类型 模板名 (形参表)
{
    函数体
};
```

- **传入多个参数举例**

```c++
template <class T1, class T2>
T2 MyFun(T1 arg1, T2 arg2)
{
    cout<< arg1 << " "<< arg2<<endl;
    return arg2;
}
```

T1 是传入的第一种任意变量类型，T2 是传入的第二种任意变量类型。

# union和struct

- struct（结构体）和union（共用体）都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员; 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的,**一个struct变量的总长度等于所有成员长度之和，遵从字节对其原则**; 在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在 , **Union变量的长度等于最长的成员的长度**。
- 对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了,所以，共同体变量中起作用的成员是最后一次存放的成员; 而对于struct的不同成员赋值是互不影响的。

# class和struct

- 结构是实值类型，而类则是引用类型。把一个对象赋给另一个对象时，class复制过去的是地址，struct复制过去的是值，因此class中的两个对象会同时改变值，struct不会同时改变。

- 默认继承和访问权限不同，class继承默认和访问是private，而struct默认继承和访问是public，struct不能被声明位Protected，而class可以。
- class还可用于定义模板函数参数，像typename，但是关键字struct不能同于定义模板h函数参数
- class有**默认的**无参构造函数，有析构函数，struct没有默认的无参构造函数，且只能声明构造函数，没有析构函数
- class必须使用new初始化(A s=new A(10);)，而结构体可以不用new初始化
- class实例由垃圾回收机制来保证内存的回收处理，而struct变量容使用完后立即自动解除内存分配

C++保留struct关键字，原因

- 保证与C语言的向下兼容性，C++必须提供一个struct
- C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制
- 对struct定义的扩展使C语言的代码能够更容易的被移植到C++中

# new对象和直接声明对象区别

1 .new创建类对象需要进行初始化，多处使用  A* a=new A() 在**堆**(heap)上分配空间，堆上空间需要手动回收 （delete）,声明对象直接 声明即可A a 在**栈**(stack)上分配空间，栈上空间自动回收。

2 .new出来的对象类似于申请空间，因此需要delete销毁，并且要把指针置为NULL；而直接声明的对象则在使用完直接销毁，理论上不会存在**内存泄漏**。

3 .new对象指针用途广泛，比如作为函数返回值、函数参数等

4 .频繁调用场合并不适合new，就像new申请和释放内存一样。

5 .new对象调用其方法以及变量需要用箭头指向其地址 a->，直接声明只需要点调用他的方法以及变量a.

# 数组和链表

​	1、存储空间上：数组在内存中是连续的，从栈中分配空间；链表是可以不连续的，从堆中分配空间。

​	2、在查询，访问方式上：数组可以随机访问其中的元素，查找速度相对较快，链表则必须是顺序访问，不能随机访问。

​	3、空间的使用上：链表对内存空间的利用率较高，可扩展性高；数组则不能，数组的空间大小是固定的，不适合动态存储，不方便动态添加。

​	4、添加或删除元素时，数组比链表慢，因为数组要移动大量的元素，而链表只需修改指针即可。

# 堆和栈的区别

- **管理方式不同：**栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放，且自己定申请内存的大小。
- **空间大小不同：**栈的空间是有限的，在32位平台下，Windows下默认为1M，组大为2M，堆最大可以到4G；
- **能否产生碎片：**栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free对造成内存碎片很多。
- **生长方向不同：**堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长。
- **分配方式不同：**堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。
- **分配效率不同：**栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。

**为什么要区分堆和栈**

在我们学习 C/C++ 和 Java 等编程语言的时候经常要学习一个概念就是堆和栈，对于大部分经验丰富的工程师来说，堆和栈是再熟悉不过的东西了，堆和栈都是存储程序运行时变量的地方。但这个时候问题来了，既然两个都是存储**临时变量**的地方，那么为什么那么多编程语言既需要栈也需要堆呢。

- 栈和堆结构的特性

栈一般来说都是一个 “后进先出” 队列，后进入的数据，会先被释放掉。而堆一般是个链表或者树结构，不同语言有不同实现，相对而言复杂的多。

- 为什么既需要栈又需要堆

在数学中，我们经常使用反证法来证明问题，在这里我们也可以按照反证的思路去思考这个问题。

- 仅使用栈

假设我们的程序代码仅仅使用栈，那么我们的代码会变得非常的简单，程序在执行函数的时候，只需要依次的将变量压入堆栈就好了，当要释放的时候取出来就好了，针对实现的时候，只需要让指针上下移动就好。这么一看栈似乎很完美，它性能优越快速，而且不会产生内存碎片。但是假设我们现在有这么一个操作现在有两个变量 A,B 我们先依次把他们入栈，入栈后的后续操作我们主要是围绕 B 进行的，与 A 已经没有关系了，但是 A 依旧占用着空间，如果我们希望释放 A 的内存空间，那么根据后进先出的原则，那么我们必须先释放 B 才能释放 A，但是后续的计算又需要 B 这就导致我们无法释放 A，在后续的过程中 A 已经没有价值了，但是它还是必须驻留在内存中。而这个时候如果将 A 放入堆中，那么当 A 不在使用的时候，我们可以很容易的在堆中释放 A 所占用的空间，提高内存的有效使用率。这就是堆出现的初衷。

- 仅使用堆

堆之所以能与比栈更好的动态分配的性能是因为堆往往使用了较为复杂的数据结构，这就会导致操作堆的成本要远远大于栈的成本，所以如果仅仅使用堆会使的程序整体效率变慢。

- 总结

类似计算机科学中的很多场景，我们在选择技术方案的时候往往根据不同的场景选择更为合适的策略，而不是选择单一策略。在编程语言中由于堆和栈不同的特性，他们被分别设计用于做动态内存分配和静态快速内存分配，在这样的划分中一起提高了整体系统的效率。

# 浅拷贝和深拷贝

**转自：**https://www.cnblogs.com/mikeCao/p/8710837.html

- 深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。

假设B复制了A，修改A的时候，看B是否发生变化：

如果B跟着**也变了**，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）

如果B**没有改变**，说明是深拷贝，自食其力！（修改堆内存中的不同的值）

<br></br>

浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，

深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，

使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。

浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。

深复制：在计算机中开辟一块**新的内存地址**用于存放复制的对象。

# 友元

https://blog.csdn.net/weixin_42513339/article/details/81101644

# 大端小端

- 大端与小端是用来描述多字节数据在内存中的存放顺序，即字节序。**大端（Big Endian）**指低地址端存放高位字节，**小端（Little Endian）**是指低地址端存放低位字节。
- 需要记住计算机是**以字节为存储单位**。
- 为了方便记忆可把大端和小端称作高尾端和低尾端，eg：如果是高尾端模式一个字符串“11223344”把尾部“44”放在地址的高位，如果是低尾端模式，把“44”放在地址的低位。

各自优势：

- **Big Endian**：符号位的判定固定为第一个字节，容易判断正负。
- **Little Endian**：长度为1，2，4字节的数，排列方式都是一样的，数据类型转换非常方便。

**举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：**

- 1)大端模式：

低地址 -----------------> 高地址
**0x12 | 0x34 | 0x56 | 0x78**

- 2)小端模式：

低地址 ------------------> 高地址
**0x78 | 0x56 | 0x34 | 0x12**

还可以借助union来判断

在c中，union存放字节都是从低地址开始存放。

```c++
int checkCPU()
{
　　union w
　　{
 　　　int a;
 　　　char b;
　　}c;
　　c.a = 1;
　　return (c.b == 1);  // 小端返回TRUE,大端返回FALSE
}
```

# 内联函数（inline）

内联函数的基本思想在于将每个函数调用以它的代码体来替换，很可能会增加整个目标代码的体积过分地使用内联所产生的程序会因为有太大的体积而导致可用空间不够。

**内联函数和宏定义的区别**

​    内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 

​    另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。