---
title: linux下的fork（）函数
tags: 操作系统
category: CS大学生必备 
date: 2020/03/23 16:18
---

PID（Process Indentifier）进程识别符，是各进程的身份识别

<!--more-->

<font size=4>

# 深度剖析fork()的原理及用法

​       我们都知道通过fork()系统调用我们可以创建一个和当前进程一样的新进程，我们通常将新进程称为子进程,而当前进程称为父进程.而子进程继承了父进程的整个地址空间,其中包括了进程上下文、堆栈地址、内存信息、进程控制块(PCB)等.

## 父子进程

那么我们首先来先说说父进程和子进程之间的区别:

- 父进程设置了锁,子进程不继承
- 进程ID不同
- 子进程的未决告警被清除
- 子进程的未决信号集设置为空集

## fork系统调用说明

　　fork()包含的头文件<sys/types.h>和<unistd.h>,功能就是创建一个子进程.函数原型:pid_t fork(void),pid_t是带一个代表经常号pid的数据结构.如果创建成功一个子进程,对于父进程来说是返回子进程的ID.而对于子进程来说就是返回0.而返回-1代表创建子进程失败.

## fork()系统调用注意点：

通过以上程序我们可以知道：

- 1）fork系统调用之后，父进程和子进程交替执行，并且它们处于不同空间中。

- 2）fork()函数的一次调用返回2次返回，这个有点抽象难理解,此时二个进程处于独立的空间,它们各自执行者自己的东西,不产生冲突,所以返回2次一次pid=0,一次pid大于0.而至于是先子进程还是父进程先执行,这没有确切的规定,是随机的.

- 3)将fork()返回值大于零设置为父进程,这是因为子进程获得父进程的pid相对容易,而父进程获子进程pid比较难,所以在fork()系统调用中将子进程自己的pid字节作为返回值返回给父进程.

- 4)fork()的子执行过程在fork()之后并不是从头开始,因为在fork()之前,父进程已经为子进程搭建好了运行环境了.所以从字节有效代码处开始。

## vfork()系统调用:

　　那么讲完了fork(),我们不妨和vfork()比较,并且学习终结一下vfork();vfork()在某些情况下,我们知道vfork()与fork()执行结果是一样的,除了子进程会执行一次exec系统调用或者调用exit(0)退出.函数原型:pid_t vfork vfork(void),具体返回值与其中fork()类似.　这个函数时是在没有实现写时赋值前提下,所以现在我们并不推荐使用vfork().

结论如下　　

- fork （）：子进程拷贝父进程的数据段，代码段
  vfork （）：子进程与父进程共享数据段
-  fork （）父子进程的执行次序不确定
    vfork 保证子进程先运行，在调用exec 或\_exit 之前与父进程数据是共享的,在它调用exec或\_exit 之后父进程才可能被调度运行。
- vfork （）保证子进程先运行，在她调用exec 或exit 之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。

vfork()通常我们都是与exec函数在一起,在主进程中替换进程印象.

为什么会有vfork，因为以前的fork 很傻， 它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而往往在子进程中会执行exec 调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子 霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec 或者exit 后，相 于儿子买了自己的房子了，这时候就相于分家了。

## 举例

一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是**两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事**。
  一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。

例子如下

```c++
#include <unistd.h>
#include <stdio.h>
int main ()
{
    pid_t fpid; //pid_t表示一个类型,fpid表示fork函数返回的值
    int count=0;
    fpid=fork();
    if (fpid < 0)
        printf("error in fork!\n");
    else if (fpid == 0) {
        printf("i am the child process, my process id is %d\n",getpid());
        printf("我是爹的儿子\n");//对某些人来说中文看着更直白。
        count++;
    }
    else {
        printf("i am the parent process, my process id is %d\n",getpid());
        printf("我是孩子他爹\n");
        count++;
    }
    printf("统计结果是: %d\n",count);
    return 0;
}
/*
i am the parent process, my process id is 24703
我是孩子他爹
统计结果是: 1
i am the child process, my process id is 24704
我是爹的儿子
统计结果是: 1
*/
```

  在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。

  引用一位网友的话来解释fpid的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id,

因为子进程没有子进程，所以其fpid为0.