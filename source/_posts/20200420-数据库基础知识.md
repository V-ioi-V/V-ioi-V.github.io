---
title: 数据库基础知识
tags: 数据库
category: CS大学生必备
date: 2020/04/20 16:52
---

<font size=4>

# 主键和外键

**主键：**关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键。

**外键：**如果一个字段X在一张表（表一）中是主键，而在另外一张表（表二）中不是主键，则字段X称为表二的外键

# 为何不为所有属性建立索引

1.不是每个属性都要必要建立索引，一般要看这个属性是不是比较重要或者用的比较多
2.建立索引需要耗费存储空间
3.索引需要定期维护，维护比较麻烦，有时候需要重建
4.某条件查询效率低下，而且数据量大的时候可以考虑建索引

# 最左前缀原则

**最左前缀原则**：mysql索引可以引用多列，叫联合索引，如果查询条件精确匹配联合索引的左边连续一列或者多列，则查询命中索引。a,b,c的联合索引，(a,c)可以命中a,c不能命中。

联合索引并不是全部不中，或者全部中。可以只命中一部分，例如单单命中a

# 什么时候建索引

索引可以提高数据的检索效率，也可以降低数据库的IO成本，并且索引还可以降低数据库的排序成本。排序分组操作主要消耗的就是CPU资源和内存，所以能够在排序分组操作中好好的利用索引将会极大地降低CPU资源的消耗。

**如何判定是否需要创建索引？**

**1、较频繁地作为查询条件的字段**

这个都知道。什么是教频繁呢？分析你执行的所有SQL语句。最好将他们一个个都列出来。然后分析，发现其中有些字段在大部分的SQL语句查询时候都会用到，那么就果断为他建立索引。

**2、唯一性太差的字段不适合建立索引**

什么是唯一性太差的字段。如状态字段、类型字段。那些只存储固定几个值的字段，例如用户登录状态、消息的status等。这个涉及到了索引扫描的特性。例如：通过索引查找键值为A和B的某些数据，通过A找到某条相符合的数据，这条数据在X页上面，然后继续扫描，又发现符合A的数据出现在了Y页上面，那么存储引擎就会丢弃X页面的数据，然后存储Y页面上的数据，一直到查找完所有对应A的数据，然后查找B字段，发现X页面上面又有对应B字段的数据，那么他就会再次扫描X页面，等于X页面就会被扫描2次甚至多次。以此类推，所以同一个数据页可能会被多次重复的读取，丢弃，在读取，这无疑给存储引擎极大地增加了IO的负担。

**3、更新太频繁地字段不适合创建索引**

当你为这个字段创建索引时候，当你再次更新这个字段数据时，数据库会自动更新他的索引，所以当这个字段更新太频繁地时候那么就是不断的更新索引，性能的影响可想而知。大概被检索几十次会更新一次的字段才比较符合建立索引的规范。而如果一个字段同一个时间段内被更新多次，那么果断不能为他建立索引。

**4、不会出现在where条件中的字段不该建立索引**

# 聚集索引和非聚集索引

**聚集索引：**该索引中键值的逻辑顺序决定了表中相应行的物理顺序。

**非聚集索引：**一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。

索引是通过多路搜索树的数据结构来描述的，我们可以这么理解聚簇索引，索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。

# innoDB和MyISAM

1. **InnoDB支持事务，实现了SQL标准的四种隔离级别**，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

2. **InnoDB支持外键**，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；

3. **InnoDB是聚集索引**，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

   MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

   也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

4. **InnoDB不保存表的具体行数**，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

5. **Innodb不支持全文索引**，而MyISAM支持全文索引，查询效率上MyISAM要高；5.7以后的InnoDB支持全文索引了

7. **InnoDB支持表、行(默认)级锁**，而MyISAM支持表级锁

   InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。

8. **InnoDB表必须有主键**（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有

**MyISAM适合：**(1)做很多count 的计算；(2)读密集；(3)没有事务。

**InnoDB适合：**(1)要求事务；(2)写密集（3）高并发

# 三大范式

**第一范式:**要求数据库表的每一列都是不可分割的原子数据项。
**第二范式:**在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）。

第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。

**第三范式:**在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。