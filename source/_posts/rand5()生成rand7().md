---
title: rand5()生成rand7()
tags: 瞎搞
category: 算法短板
date: 2020/03/11
---

# 描述

​     **假如有一个函数rand5()能等概率生成1 - 5 之间的整数，如何利用rand5()来实现rand7()，rand7()函数的要求是能够等概率生成1 - 7之间的整数。**

~~一开始想的是7个rand5()相加然后模7，还是太天真了，没想到这样每个数得出的概率不相等~~

## 方法一

```c++
int rand7(){
    while(1){
        int cnt=5*(rand5()-1)+(rand5()-1);
        if(cnt<21){
            return cnt%7+1;
        }
    }
}
```

- 两次使用rand5()，可以生成1-25的所有数。5 * (rand5() - 1) 可以生成 0 - 20，而后面的则可以生成0 - 4。用数学表达的话就是 [0, 24]。

- 关于平均分布：5*(rand5()-1) 生成的是 0, 5,10,15,20各20%的概率，rand5()-1 是0,1,2,3,4各20%概率，两者相加，就是0-24各1/25的概率,每个数只能通过特定的两个数组成，不存在多种组成情况，这样就保证了平均分布的问题了。

- 前21个是平均分布，前14个也是，前7个也是，但是增加了可能的循环次数。当while里面的条件不满足，循环就会一直下去。所以从程序上考虑，21的话要比7和14要循环的次数少很多。

## 方法二

```c++
int rand01() {
    int i = rand5();
    while (i > 4) { i = rand5(); }
    return i % 2;
}

int rand07() {
    return rand01() << 2 + rand01() << 1 + rand01();
}

int rand7() {
    int i = rand07();
    while (i == 0) { i = rand07(); }
    return i;
}
```

**二进制搞法**

- 首先用rand5()产生等概率的0和1，很好搞
- 再用rand01()去凑7的二进制的每一位，因为0和1的概率都是相同的，所以从0到7的每一位都是相同的，但是这个方法不仅仅适用于二进制全是1的数，就算有的位数不是1，只要补上1，最后再把不适合的数去掉即可
- 最后用rand7()把不适合的数去掉

## 方法三

~~典型的笨办法~~

~~~c++
int rand7()
{
    int vals[5][5] = {
            {1,2,3,4,5},
            {6,7,1,2,3},
            {4,5,6,7,1},
            {2,3,4,5,6},
            {7,0,0,0,0}
    };
    int result = 0;
    while(result == 0)
    {
        int i = rand5();
        int j = rand5();
        result = vals[i - 1][j - 1];
    }
    return result;
}
~~~

- 开辟空间存数，然后把两个rand5()当做下标访问空间里的值，比较费内存

别的方法待补充...