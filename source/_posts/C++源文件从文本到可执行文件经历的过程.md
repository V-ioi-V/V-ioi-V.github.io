---
title: C++源文件从文本到可执行文件经历的过程
tags: C++
category: CS大学生必备
date: 2020/03/21 14:37
---

<font size=4>

**一个C++源文件从文本到可执行文件经历的过程**

对于一个C++源文件，从文本到可执行文件一般需要四个过程：

## 一、预处理阶段(.i)

对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，成预编译文件。

- 1.删除所有的#define，展开所有的宏定义。
- 2.处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”，将不必要的代码过滤掉。
- 3.处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。
- 4.删除所有的注释，“//”和“/**/”。
- 5.保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。作用是设定编译器的状态或者是指示编译器完成一些特定的动作。
- 6.添加行号和文件标识，便于编译时编译器产生**调试**用的行号信息，和编译时产生**编译错误或警告**是能够显示行号。

### 注意1：条件预编译指令的作用

​       条件编译最主要目的是防止重复包含和编译头文件，例如:一个c文件包含同一个h文件多次，如果不加#ifndef宏定义，会出现变量重复定义的错误。条件编译常用的有四个预处理命令：#if、#else、#elif、#endif。

​       你如果将一个函数声明2次，就会报错。所以把函数声明写在头文件中后，如果引用了2次这个头文件，也会报错。#ifndef #define 宏就是用来避免头文件重复包含的，意思是 如果没有这个内容的定义，就定义下面的内容。

​       条件编译是为了代码能在不同的环境中都编译通过，通用性更好。

### 注意2:<>和""的区别

- **#include< >**

　　#include< > 引用的是**编译器的类库路径里面的头文件**。

　　假如你编译器定义的自带头文件引用在 C:\Keil\c51\INC\ 下面，则 #include<stdio.h> 引用的就是 C:\Keil\c51\INC\stdio.h 这个头文件，不管你的项目在什么目录里， C:\Keil\c51\INC\stdio.h 这个路径就定下来了，一般是引用自带的一些头文件，如： stdio.h、conio.h、string.h、stdlib.h 等等。

- **#include" "**

　　#include" " 引用的是你**程序目录的相对路径中的头文件**。

　　假如你的项目目录是在 D:\Projects\tmp\ ，则 #include"my.h" 引用的就是 D:\Projects\tmp\my.h 这个头文件，一般是用来引用自己写的一些头文件。如果使用 #include" " ，它是会先在你项目的当前目录查找是否有对应头文件，如果没有，它还是会在对应的引用目录里面查找对应的头文件。例如，使用 #include "stdio.h" 如果在你项目目录里面，没有 stdio.h 这个头文件，它还是会定位到 C:\Keil\c51\INC\stdio.h 这个头文件的。

## 二、编译阶段(.s)

将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件。

词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
优化：源代码级别的一个优化过程。
目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。
目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

## 三、汇编阶段(.o或.obj)

将编译阶段生成的汇编文件转化成机器码，可重定位的(二进制)目标文件。
汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，**只是根据汇编指令和机器指令的对照表一一翻译过来**，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。

目标文件由段组成，通常一个目标文件中至少有两个段：

- **代码段**：该段中所包含的**主要是程序的指令**。该段一般是可读和可执行的，但一般却不可写。
- **数据段**：主要存放程序中要用到的各种**全局变量或静态的数据**。一般数据段都是可读，可写，可执行的。

## 四、链接阶段(.out或.exe)

将多个目标文件及所需要的库连接成最终的可执行目标文件。链接分为静态链接和动态链接：

静态链接和动态链接两者最大的区别就在于链接的时机不一样，**静态链接是在形成可执行程序前，而动态链接的进行则是在程序执行时**，下面来详细介绍这两种链接方式。

### 静态链接
#### 1.为什么要进行静态链接

​        在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即**每个.c文件会形成一个.o文件**，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接

#### 2.静态链接的原理

​        将多个模块依次连接起来，形成一个统一的逻辑地址空间。没有拼接前，每个模块的逻辑地址都是0，拼接起来后，逻辑地址是相连的。

​        如果有外部调用符（CALL），就会跳到连接后相应的块的逻辑地址。

​        由很多目标文件进行链接形成的是静态库，反之**静态库也可以简单地看成是一组目标文件的集合**，即很多**目标文件经过压缩打包后形成的一个文件**，如下图，使用ar命令的-a参数查看静态库的组成：

![1.jpg](https://i.loli.net/2020/04/16/BKqMVCDL53u42Ag.png)

​      以下面这个图来简单说明一下从静态链接到可执行文件的过程，根据在源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，在libc.a中找到目标文件printf.o(这里暂且不考虑printf()函数的依赖关系)，然后将这个目标文件和我们hello.o这个文件进行链接形成我们的可执行文件。

![2.jpg](https://i.loli.net/2020/04/16/fJgOF1mQZ8nCd4V.png)

​        这里有一个小问题，就是从上面的图中可以看到静态运行库里面的一个目标文件只包含一个函数，如libc.a里面的printf.o只有printf()函数，strlen.o里面只有strlen()函数。

​       我们知道，链接器在链接静态链接库的时候是以目标文件为单位的。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件就不要链接到最终的输出文件中。

#### 3.静态链接的优缺点
​        静态链接的缺点很明显，**一是浪费空间**，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；**另一方面就是更新比较困难**，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候**运行速度快**。

问题：

### 动态链接
#### 1.为什么会出现动态链接
​        动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。

#### 2.动态链接的原理
​        动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件，如果发现内存中没有这个模块，就从外存中去找到这个模块并链接内存中。下面简单介绍动态链接的过程：

​      假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

#### 3.动态链接的优缺点
​        动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

​       据估算，动态链接和静态链接相比，性能损失大约在5%以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。

### 重定位

程序和数据装入内存时需对目标程序中的地址进行修改。这种把逻辑地址转变为内存的物理地址的过程叫重定位。

对程序进行重定位的技术按重定位的时机可分为两种：静态重定位和动态重定位。

#### 1.静态重定位

静态重定位是在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的地址。对每个程序来说，这种地址变换只是在装入时一次完成，在程序运行期间不再进行重定位。

优点是：

无需增加硬件地址转换机构，便于实现程序的静态连接。在早期计算机系统中大多采用这种方案。

缺点是：

（1）程序的存储空间只能是连续的一片区域，而且在重定位之后就不能再移动。这不利于内存空间的有效使用。（2）各个用户进程很难共享内存中的同一程序的副本。

#### 2.动态重定位

动态重定位是在程序执行期间每次访问内存之前进行重定位。这种变换是靠硬件地址变换机构实现的。通常采用一个重定位寄存器，其中放有当前正在执行的程序在内存空间中的起始地址，而地址空间中的代码在装入过程中不发生变化。

此工作由硬件地址映射机制来完成。硬件支持，软硬件结合完成） 硬件上需要一对寄存器的支持。程序放在不连续的实际物理空间中，要进行逻辑地址到物理地址的转换，实现动态重定位一般需要页式存储管理，页式存储管理用的不是寄存器，使用的是称为page table(页表)的数据结构page table记录了所有逻辑地址到物理地址的转换信息，进程切换的时候需要冲洗硬件上的page table 。 

优点是：

（1）程序占用的内存空间动态可变，不必连续存放在一处。

（2）比较容易实现几个进程对同一程序副本的共享使用。
缺点是：

需要附加的硬件支持，增加了机器成本，而且实现存储管理的软件算法比较复杂。

现在一般计算机系统中都采用动态重定位方法。

---



参考自：https://blog.csdn.net/lym940928/article/details/93384917

https://blog.csdn.net/daaikuaichuan/article/details/89060957

https://blog.csdn.net/kang___xi/article/details/80210717